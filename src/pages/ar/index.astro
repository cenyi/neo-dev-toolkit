---
import BaseLayout from '../../layouts/BaseLayout.astro';
import Sidebar from '../../components/Sidebar.astro';
import { locales } from '../../i18n/locales.js';
import LanguageSwitcher from '../../components/LanguageSwitcher.astro';

// AR é¦–é¡µï¼Œå›ºå®šä½¿ç”¨arè¯­è¨€
const lang = 'ar-SA';
const t = locales['ar'];
---

<BaseLayout
  title="Ø£Ø¯ÙˆØ§Øª JSON - ØªÙ†Ø³ÙŠÙ‚ ÙˆÙ…Ù‚Ø§Ø±Ù†Ø© ÙˆØªØ­ÙˆÙŠÙ„ | Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†"
  lang={lang}
  dir="rtl"
  description="Ø£Ø¯ÙˆØ§Øª JSON Ù…Ø¬Ø§Ù†ÙŠØ© Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª: ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙˆÙ…Ù‚Ø§Ø±Ù†Ø© ÙˆØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ CSV Ùˆ Excel Ùˆ XML Ùˆ YAML. ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆØ¢Ù…Ù†."
  keywords="Ù…Ù†Ø³Ù‚ JSON,Ù…Ø¯Ù‚Ù‚ JSON,Ù…Ø­Ù„Ù„ JSON,Ù…Ù‚Ø§Ø±Ù†Ø© JSON,diff JSON,ØªØ¶ÙŠÙŠÙ‚ JSON,JSON Ø¥Ù„Ù‰ CSV,JSON Ø¥Ù„Ù‰ Excel,Ø£Ø¯ÙˆØ§Øª JSON">
  <Sidebar slot="sidebar" t={t} />
  <div slot="header">
    <LanguageSwitcher currentLocale="ar" />
  </div>

  <!-- Schema.org ç»“æ„åŒ–æ•°æ®ç”¨äº SEO & GEO -->
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Ø£Ø¯ÙˆØ§Øª JSON - ØªÙ†Ø³ÙŠÙ‚ ÙˆÙ…Ù‚Ø§Ø±Ù†Ø© ÙˆØªØ­ÙˆÙŠÙ„",
    "description": "Ø£Ø¯ÙˆØ§Øª JSON Ù…Ø¬Ø§Ù†ÙŠØ© Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª: ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙˆÙ…Ù‚Ø§Ø±Ù†Ø© ÙˆØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ CSV Ùˆ Excel Ùˆ XML Ùˆ YAML. ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØµÙØ­ ÙˆØ¢Ù…Ù†.",
    "url": "https://tojsons.com/ar",
    "applicationCategory": "DeveloperApplication",
    "operatingSystem": "Any",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "CNY"
    },
    "featureList": [
      "ØªÙ†Ø³ÙŠÙ‚ JSON ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­ØªÙ‡",
      "ØªØ­Ù„ÙŠÙ„ Ù…Ø¹Ù„Ù…Ø§Øª URL",
      "XML Ø¥Ù„Ù‰ JSON",
      "YAML Ø¥Ù„Ù‰ JSON",
      "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø­Ù‚ÙˆÙ„ JavaScript",
      "ØªÙˆÙ„ÙŠØ¯ ÙˆØ§Ø¬Ù‡Ø§Øª TypeScript",
      "JSON Ø¥Ù„Ù‰ XML",
      "Ø¶ØºØ· JSON",
      "Ù‡Ø±ÙˆØ¨ JSON",
      "Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª"
    ],
    "browserRequirements": "éœ€è¦JavaScriptæ”¯æŒã€‚å…¼å®¹æ‰€æœ‰ç°ä»£æµè§ˆå™¨ã€‚",
    "softwareVersion": "1.0.0",
    "author": {
      "@type": "Organization",
      "name": "JSON Viewer Team"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "1250"
    }
  })} />

  <div class="json-formatter-container"
       data-enter-extraction-fn={t.enterExtractionFn}
       data-enter-data={t.enterData}
       data-extraction-error={t.extractionError}
       data-parsing-error={t.parsingError}
       data-compress-success={t.compressSuccess}
       data-escape-success={t.escapeSuccess}
       data-xml-success={t.xmlSuccess}
       data-ts-success={t.tsSuccess}
       data-csv-success={t.csvSuccess}
       data-excel-success={t.excelSuccess}>

    <div class="editor-workspace">
      <!-- å·¦ä¾§è¾“å…¥åŒºåŸŸ -->
      <div class="input-area">
        <!-- ç¼–è¾‘å™¨å®¹å™¨ï¼ˆç”¨äºå·¦å³å¸ƒå±€ï¼‰ -->
        <div class="editors-wrapper" id="editors-wrapper">
          <!-- ä¸¤ä¸ªç‹¬ç«‹ç¼–è¾‘å™¨ -->
          <div class="input-section">
            <div class="section-header-row">
              <h1 class="section-label">Ø£Ø¯Ø§Ø© JSON Ø´Ø§Ù…Ù„Ø©</h1>
              <div class="editor-hint-inline" id="editor-hint">
                <span class="hint-icon">âœ¨</span>
                <span class="hint-text">{t.smartInput}</span>
              </div>
            </div>
            <div class="input-editor-wrapper">
              <div id="monaco-editor-container" class="monaco-editor-container"></div>
            </div>
          </div>

          <!-- æ¯”è¾ƒæ¨¡å¼ï¼šç¬¬äºŒä¸ªç¼–è¾‘å™¨ -->
          <div class="input-section compare-editor hidden" id="compare-section">
            <h2 class="section-label">JSON Ø§Ù„Ø£ÙŠÙ…Ù† (Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©)</h2>
            <div class="input-editor-wrapper">
              <div id="monaco-compare-container" class="monaco-editor-container"></div>
            </div>
          </div>
        </div>

        <!-- JSON æ ¡éªŒé”™è¯¯æç¤º -->
        <div id="json-validation-error" class="validation-error hidden"></div>

        <div class="extraction-section">
          <div class="extraction-controls">
            <label for="extract-fn">ğŸ“Š Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­Ù‚ÙˆÙ„</label>
            <input
              type="text"
              id="extract-fn"
              placeholder={t.extractionPlaceholder}
            />
            <button id="apply-extract">ØªØ·Ø¨ÙŠÙ‚</button>
            <button id="clear-extract-fn">Ù…Ø³Ø­</button>
          </div>
        </div>

        <div class="output-controls">
          <!-- åŸºç¡€æ“ä½œ -->
          <button id="collapse-all">{t.collapseAll}</button>
          <button id="expand-all">{t.expandAll}</button>
          <button id="remove-comments">{t.removeComments}</button>
          <button id="compress-copy">{t.compressCopy}</button>
          <button id="escape-copy">{t.escapeCopy}</button>

          <span class="button-separator">|</span>

          <!-- æ•°æ®æ ¼å¼è½¬æ¢ -->
          <button id="json-to-xml">{t.jsonToXml}</button>
          <button id="json-to-yaml">{t.jsonToYaml}</button>
          <button id="json-to-csv">{t.jsonToCsv}</button>
          <button id="json-to-excel">{t.jsonToExcel}</button>
          <button id="json-to-html">{t.jsonToHtml}</button>
          <button id="json-to-pdf">{t.jsonToPdf}</button>

          <span class="button-separator">|</span>

          <!-- ä»£ç ç”Ÿæˆ -->
          <button id="json-to-ts">{t.jsonToTs}</button>
          <button id="json-to-dart">{t.jsonToDart}</button>
          <button id="json-to-c">{t.jsonToC}</button>
          <button id="json-to-go">{t.jsonToGo}</button>
          <button id="json-to-rust">{t.jsonToRust}</button>
          <button id="json-to-python">{t.jsonToPython}</button>
          <button id="json-to-schema">{t.jsonToSchema}</button>

          <span class="button-separator">|</span>

          <!-- å¯è§†åŒ–ä¸åˆ†æ -->
          <button id="json-to-table">{t.jsonToTable}</button>
          <button id="json-compare">{t.jsonCompare}</button>

          <span class="button-separator">|</span>

          <!-- å…¶ä»– -->
          <button id="clear-btn">Ù…Ø³Ø­</button>
          <button id="history-btn">{t.history}</button>
          <select id="font-size-select" title="å­—ä½“å¤§å°">
            <option value="11">11px</option>
            <option value="12">12px</option>
            <option value="13" selected>13px</option>
            <option value="14">14px</option>
            <option value="15">15px</option>
            <option value="16">16px</option>
          </select>
        </div>
      </div>

      <!-- å³ä¾§è¾“å‡ºåŒºåŸŸ -->
      <div class="output-area" id="output-area">
        <div class="output-header">
          <span class="output-title" id="output-title">è¾“å‡ºç»“æœ</span>
          <button class="close-output-btn" id="close-output" title="å…³é—­">Ã—</button>
        </div>
        <div class="output-content" id="output-content">
          <div class="output-editor-wrapper">
            <div id="output-monaco-container" class="monaco-editor-container"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- HowTo æ•™ç¨‹åŒºåŸŸ -->
  <div class="tutorial-section">
    <div class="section-header">
      <h2>ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø¯ÙˆØ§Øª JSON</h2>
      <p>ØªØ¹Ø±Ù Ø¹Ù„Ù‰ ÙƒÙŠÙÙŠØ© ØªÙ†Ø³ÙŠÙ‚ ÙˆØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙˆØªØ­ÙˆÙŠÙ„ JSON Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø¯ÙˆØ§ØªÙ†Ø§ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©</p>
    </div>

    <div class="tutorial-container">
      <div class="tutorial-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <h3>Ù„ØµÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h3>
          <p>Ù„ØµÙ‚ Ø¨ÙŠØ§Ù†Ø§Øª JSON Ø£Ùˆ Ù…Ø¹Ù„Ù…Ø§Øª URL Ø£Ùˆ XML Ø£Ùˆ YAML ÙÙŠ Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„.</p>
          <div class="step-example">
            <code>{"name": "Ù…Ø«Ø§Ù„", "value": 123}</code>
          </div>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <h3>Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚</h3>
          <p>Ø³ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø£Ø¯Ø§Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ø®Ø·Ø§Ø¡.</p>
          <div class="tip">
            <strong>ğŸ’¡è´´å£«ï¼š</strong> ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙØªØ§Ø­ Ø§Ù„Ù‚Ù„Ø¨ Ctrl+Enter Ù„ØªÙ†Ø³ÙŠÙ‚ ØªÙ„Ù‚Ø§Ø¦ÙŠ.
          </div>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <h3>Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªÙŠØ¬Ø©</h3>
          <p>Ø´Ø§Ù‡Ø¯ JSON Ø§Ù„Ù…ÙÙ†Ø³Ù‚ Ù…Ø¹ Ø§Ù„ØªÙ…ÙŠÙŠØ² Ø§Ù„Ø¨Ù†ÙŠÙˆÙŠ ÙˆØ§Ù„Ø®Ø·Ø£ Ø§Ù„Ù…ÙØ¨Ø±Ø².</p>
          <div class="step-example">
            <code>{"name": "Ù…Ø«Ø§Ù„", "value": 123}</code>
          </div>
          <p class="example-desc">JSON Ø§Ù„Ù…ÙÙ†Ø³Ù‚ Ù…Ø¹ Ø§Ù„ØªÙ…ÙŠÙŠØ² Ø§Ù„Ø¨Ù†ÙŠÙˆÙŠ.</p>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <h3>Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­Ù‚ÙˆÙ„</h3>
          <p>Ø§Ø³ØªØ®Ø¯Ù… ÙˆØ¸ÙŠÙØ© Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø­Ù‚ÙˆÙ„ Ù…Ø­Ø¯Ø¯Ø© Ù…Ù† JSON.</p>
          <div class="step-example">
            <pre>obj => obj.name</pre>
          </div>
          <p class="example-desc">Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­Ù‚Ù„ "Ø§Ù„Ø§Ø³Ù…" Ù…Ù† ÙƒØ§Ø¦Ù† JSON.</p>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <h3>ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª</h3>
          <p>Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù„ØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø£Ø®Ø±Ù‰:</p>
          <ul class="action-list">
            <li><strong>ğŸ“‹ JSON Ø¥Ù„Ù‰ CSVï¼š</strong> ØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ CSV</li>
            <li><strong>ğŸ“Š JSON Ø¥Ù„Ù‰ Excelï¼š</strong> ØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ Ù…Ù„Ù Excel</li>
            <li><strong>ğŸ”„ JSON Ø¥Ù„Ù‰ XMLï¼š</strong> ØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ XML</li>
            <li><strong>ğŸ“ JSON Ø¥Ù„Ù‰ YAMLï¼š</strong> ØªØ­ÙˆÙŠÙ„ JSON Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ YAML</li>
            <li><strong>ğŸ’» JSON Ø¥Ù„Ù‰ TypeScriptï¼š</strong> Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ø¬Ù‡Ø§Øª TypeScript Ù…Ù† JSON</li>
          </ul>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">6</div>
        <div class="step-content">
          <h3>Ø§Ù„Ø®ØµÙˆØµÙŠØ© ÙˆØ§Ù„Ø¢Ù…Ø§Ù†</h3>
          <p>Ø¬Ù…ÙŠØ¹ Ù…Ø¹Ø§Ù„Ø¬Ø© JSON ØªØ­Ø¯Ø« Ù…Ø­Ù„ÙŠÙ‹Ø§ ÙÙŠ Ù…ØªØµÙØ­ÙƒØŒ Ø¯ÙˆÙ† Ø£ÙŠ Ø±ÙØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ø®ÙˆØ§Ø¯Ù….</p>
          <div class="privacy-note">
            <strong>ğŸ”’ Ø§Ù„Ø®ØµÙˆØµÙŠØ©ï¼š</strong> Ù„Ø§ ÙŠØªÙ… ØªØ´ÙÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ùˆ ØªØ®Ø²ÙŠÙ†Ù‡Ø§ Ø¹Ù„Ù‰ Ø®ÙˆØ§Ø¯Ù…Ù†Ø§.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Features Section -->
    <div class="features-section">
      <div class="section-header">
        <h2>Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</h2>
        <p>Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ø¯ÙˆØ§Øª JSON Ø´Ø§Ù…Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ø­ØªÙŠØ§Ø¬Ø§ØªÙƒ</p>
      </div>
      <div class="features-grid">
        <div class="feature-item">
          <div class="feature-number">01</div>
          <div class="feature-content">
            <div class="feature-icon">âœ¨</div>
            <h3>{t.feature1Title}</h3>
            <p>{t.feature1Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">02</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ”„</div>
            <h3>{t.feature2Title}</h3>
            <p>{t.feature2Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">03</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ¯</div>
            <h3>{t.feature3Title}</h3>
            <p>{t.feature3Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">04</div>
          <div class="feature-content">
            <div class="feature-icon">âš¡</div>
            <h3>{t.feature4Title}</h3>
            <p>{t.feature4Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">05</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ’»</div>
            <h3>{t.feature5Title}</h3>
            <p>{t.feature5Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">06</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ”’</div>
            <h3>{t.feature6Title}</h3>
            <p>{t.feature6Desc}</p>
          </div>
        </div>
      </div>
    </div>

    <!-- æ”¯æŒçš„åŠŸèƒ½ Section -->
    <div class="supported-formats-section">
      <div class="section-header">
        <h2>æ”¯æŒçš„JSONè½¬æ¢åŠŸèƒ½</h2>
        <p>ä¸€ç«™å¼JSONå·¥å…·é›†ï¼Œæ»¡è¶³æ‚¨çš„æ‰€æœ‰JSONå¤„ç†éœ€æ±‚</p>
      </div>
      <div class="formats-grid">
        <div class="format-category">
          <h3>ğŸ“Š JSONæ ¼å¼åŒ–</h3>
          <ul>
            <li>JSONæ ¼å¼åŒ– (JSON Formatter)</li>
            <li>JSONç¾åŒ– (JSON Beautifier)</li>
            <li>JSONå‹ç¼© (JSON Minify)</li>
            <li>JSONæ ¡éªŒ (JSON Validator)</li>
            <li>JSONè½¬ä¹‰ (JSON Escape)</li>
            <li>JSONæŸ¥çœ‹å™¨ (JSON Viewer)</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>ğŸ”„ JSONè½¬æ¢</h3>
          <ul>
            <li>JSONè½¬CSV (JSON to CSV Converter)</li>
            <li>JSONè½¬Excel (JSON to Excel)</li>
            <li>JSONè½¬XML (JSON to XML)</li>
            <li>JSONè½¬YAML (JSON to YAML)</li>
            <li>JSONè½¬TypeScript (JSON to TS)</li>
            <li>JSONè½¬è¡¨æ ¼ (JSON to Table)</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>â¡ï¸ è½¬æ¢ä¸ºJSON</h3>
          <ul>
            <li>CSVè½¬JSON (CSV to JSON)</li>
            <li>Excelè½¬JSON (Excel to JSON)</li>
            <li>XMLè½¬JSON (XML to JSON)</li>
            <li>YAMLè½¬JSON (YAML to JSON)</li>
            <li>URLå‚æ•°è½¬JSON (URL Params to JSON)</li>
            <li>å­—ç¬¦ä¸²è½¬JSON (String to JSON)</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>ğŸ”§ JSONå·¥å…·</h3>
          <ul>
            <li>JSONå¯¹æ¯” (JSON Compare / JSON Diff)</li>
            <li>JSONåœ¨çº¿å¯¹æ¯” (Compare JSON Online)</li>
            <li>JSONå­—æ®µæå– (Field Extraction)</li>
            <li>JSONè·¯å¾„æŸ¥æ‰¾ (JSON Path Finder)</li>
            <li>JSONå†å²è®°å½• (JSON History)</li>
            <li>JSONæ³¨é‡Šç§»é™¤ (Remove Comments)</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>ğŸ’» å¼€å‘è€…å·¥å…·</h3>
          <ul>
            <li>TypeScriptæ¥å£ç”Ÿæˆ (TS Interface)</li>
            <li>JSON Schemaç”Ÿæˆå™¨</li>
            <li>JSONä»£ç ç¤ºä¾‹</li>
            <li>JSONè¯­æ³•é«˜äº®</li>
            <li>JSONé”™è¯¯æ£€æµ‹ (JSON Error Check)</li>
            <li>JSONè¡Œå·æ˜¾ç¤º</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>ğŸ”’ å®‰å…¨ç‰¹æ€§</h3>
          <ul>
            <li>100%æµè§ˆå™¨è¿è¡Œ (Browser-based)</li>
            <li>æ•°æ®æœ¬åœ°å¤„ç† (Local Processing)</li>
            <li>æ— éœ€ä¸Šä¼ æœåŠ¡å™¨ (No Server Upload)</li>
            <li>ç¦»çº¿å¯ç”¨ (Works Offline)</li>
            <li>éšç§ä¿æŠ¤ (Privacy First)</li>
            <li>å®‰å…¨åŠ å¯† (Secure Processing)</li>
          </ul>
        </div>
      </div>
      <div class="formats-note">
        <p>ğŸ’¡ <strong>æç¤ºï¼š</strong> æ‰€æœ‰JSONå¤„ç†å‡åœ¨æµè§ˆå™¨æœ¬åœ°å®Œæˆï¼Œæ”¯æŒå¤§å‹JSONæ–‡ä»¶ï¼Œæä¾›è¯­æ³•é«˜äº®ã€é”™è¯¯æç¤ºã€æ™ºèƒ½æŠ˜å ç­‰åŠŸèƒ½ã€‚é€‚ç”¨äºå¼€å‘è€…ã€æ•°æ®åˆ†æå¸ˆã€APIæµ‹è¯•ç­‰åœºæ™¯ã€‚</p>
      </div>
    </div>

    <!-- FAQ Section -->
    <div class="faq-section">
      <div class="section-header">
        <h2>Ø£Ø³Ø¦Ù„Ø© Ø´Ø§Ø¦Ø¹Ø©</h2>
        <p>Ø¥Ø¬Ø§Ø¨Ø§Øª Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© Ø­ÙˆÙ„ Ø£Ø¯ÙˆØ§Øª JSON</p>
      </div>
      <div class="faq-grid">
        <div class="faq-item">
          <h3>{t.q1}</h3>
          <p>{t.a1}</p>
        </div>
        <div class="faq-item">
          <h3>{t.q2}</h3>
          <p>{t.a2}</p>
        </div>
        <div class="faq-item">
          <h3>{t.q3}</h3>
          <p>{t.a3}</p>
        </div>
        <div class="faq-item">
          <h3>{t.q4}</h3>
          <p>{t.a4}</p>
        </div>
        <div class="faq-item">
          <h3>{t.q5}</h3>
          <p>{t.a5}</p>
        </div>
        <div class="faq-item">
          <h3>{t.q6}</h3>
          <p>{t.a6}</p>
        </div>
      </div>
    </div>
  </div>

  <!-- FAQPage ç»“æ„åŒ–æ•°æ®ç”¨äº GEO -->
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "æˆ‘çš„æ•°æ®å®‰å…¨å—ï¼Ÿ",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "æ˜¯çš„ï¼æ‰€æœ‰æ•°æ®å¤„ç†éƒ½åœ¨æ‚¨çš„æµè§ˆå™¨æœ¬åœ°è¿›è¡Œã€‚æˆ‘ä»¬ç»ä¸ä¼šå°†æ‚¨çš„æ•°æ®å‘é€åˆ°ä»»ä½•æœåŠ¡å™¨ã€‚"
        }
      },
      {
        "@type": "Question",
        "name": "æ”¯æŒå“ªäº›æ–‡ä»¶æ ¼å¼ï¼Ÿ",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "æˆ‘ä»¬æ”¯æŒ JSONã€URL å‚æ•°ã€XML å’Œ YAMLã€‚åªéœ€ç²˜è´´æ‚¨çš„æ•°æ®ï¼Œæˆ‘ä»¬ä¼šè‡ªåŠ¨æ£€æµ‹æ ¼å¼ã€‚"
        }
      },
      {
        "@type": "Question",
        "name": "æˆ‘å¯ä»¥ä» JSON ä¸­æå–ç‰¹å®šå­—æ®µå—ï¼Ÿ",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "å¯ä»¥ï¼ä½¿ç”¨æå–å‡½æ•°å­—æ®µç¼–å†™ JavaScript å‡½æ•°ï¼Œå¦‚ 'obj => obj.name' æ¥æå–ç‰¹å®šæ•°æ®ã€‚"
        }
      },
      {
        "@type": "Question",
        "name": "è¿™ä¸ªå·¥å…·å…è´¹ä½¿ç”¨å—ï¼Ÿ",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "æ˜¯çš„ï¼Œè¿™ä¸ªå·¥å…·å®Œå…¨å…è´¹ï¼Œæ²¡æœ‰ä»»ä½•é™åˆ¶ã€‚å°½æƒ…ä½¿ç”¨å§ï¼"
        }
      },
      {
        "@type": "Question",
        "name": "å®ƒå¯ä»¥ç¦»çº¿å·¥ä½œå—ï¼Ÿ",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "åŠ è½½åï¼Œå·¥å…·å®Œå…¨ç¦»çº¿å·¥ä½œã€‚ä¸éœ€è¦äº’è”ç½‘è¿æ¥ã€‚"
        }
      },
      {
        "@type": "Question",
        "name": "æˆ‘å¯ä»¥åœ¨æ‰‹æœºä¸Šä½¿ç”¨å—ï¼Ÿ",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "å¯ä»¥ï¼è¯¥å·¥å…·å®Œå…¨å“åº”å¼ï¼Œåœ¨æ‰‹æœºå’Œå¹³æ¿ç”µè„‘ä¸Šéƒ½èƒ½å®Œç¾è¿è¡Œã€‚"
        }
      }
    ]
  })} />

  <!-- HowTo ç»“æ„åŒ–æ•°æ®ç”¨äº GEO -->
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "HowTo",
    "name": "ÙƒÙŠÙÙŠØ© ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© JSON",
    "description": "ØªØ¹Ù„Ù… ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ø§Ø±Ø¶ JSON Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª Ù„ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙˆØªØ­ÙˆÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª JSON.",
    "step": [
      {
        "@type": "HowToStep",
        "name": "Ø§Ù„ØµÙ‚ Ø¨ÙŠØ§Ù†Ø§Øª JSON",
        "text": "Ø§Ù„ØµÙ‚ Ø¨ÙŠØ§Ù†Ø§Øª JSON Ø£Ùˆ Ù…Ø¹Ù„Ù…Ø§Øª URL Ø£Ùˆ XML Ø£Ùˆ YAML ÙÙŠ Ù…Ø­Ø±Ø± Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„."
      },
      {
        "@type": "HowToStep",
        "name": "Ø§Ù„ÙƒØ´Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚",
        "text": "Ø³ÙŠÙƒØªØ´Ù Ø§Ù„Ø£Ø¯Ø§Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ ÙˆÙŠØ­ÙˆÙ„Ù‡ Ø¥Ù„Ù‰ JSON."
      },
      {
        "@type": "HowToStep",
        "name": "Ø¹Ø±Ø¶ JSON Ø§Ù„Ù…Ù†Ø³Ù‚",
        "text": "Ø§Ø¹Ø±Ø¶ JSON Ù…Ù†Ø³Ù‚Ø§Ù‹ Ø¨Ø´ÙƒÙ„ Ø¬Ù…ÙŠÙ„ Ù…Ø¹ ØªÙ…ÙŠÙŠØ² Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ù…Ù„Ø© ÙˆØ£Ø±Ù‚Ø§Ù… Ø§Ù„Ø£Ø³Ø·Ø±."
      },
      {
        "@type": "HowToStep",
        "name": "Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© JSON",
        "text": "Ø³ÙŠØªÙ… ØªÙ…ÙŠÙŠØ² Ø£ÙŠ Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ JSON ÙˆØ¥Ø¹Ø·Ø§Ø¡ Ø±Ù‚Ù… Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯ ÙˆÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø·Ø£."
      },
      {
        "@type": "HowToStep",
        "name": "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ùˆ ØªØ­ÙˆÙŠÙ„",
        "text": "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø£Ùˆ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ XML/YAML/TypeScript Ø£Ùˆ Ø¶ØºØ·/Ù†Ø³Ø® Ø§Ù„Ù†ØªÙŠØ¬Ø©."
      }
    ],
    "tool": [
      {
        "@type": "HowToTool",
        "name": "Ø¹Ø§Ø±Ø¶ JSON Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†"
      }
    ]
  })} />
</BaseLayout>

<style>
  .json-formatter-container {
    max-width: 1800px;
    margin: 0 auto;
    padding: 8px;
    height: calc(100vh - var(--sidebar-height, 40px));
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
  }

  /* ä¸»å·¥ä½œåŒº - å·¦å³å¸ƒå±€ */
  .editor-workspace {
    display: flex;
    gap: 0;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  /* å·¦ä¾§è¾“å…¥åŒºåŸŸ */
  .input-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
    min-width: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    margin: 0 auto;
    max-width: 75%;
  }

  /* å½“è¾“å‡ºåŒºåŸŸå±•å¼€æ—¶ï¼Œè°ƒæ•´å¸ƒå±€ */
  .output-area.expanded {
    flex: 1;
    width: 50%;
    opacity: 1;
    border-left: 1px solid #e5e7eb;
    padding-left: 0;
  }

  /* å½“è¾“å‡ºåŒºåŸŸå±•å¼€æ—¶ï¼Œè¾“å…¥åŒºåŸŸä¹Ÿè°ƒæ•´ä¸º50% */
  .editor-workspace:has(.output-area.expanded) .input-area {
    flex: 1;
    max-width: 50%;
    margin: 0;
  }

  /* ç§»åŠ¨ç«¯ä¼˜åŒ–è¾“å…¥åŒºåŸŸå¸ƒå±€ */
  @media (max-width: 768px) {
    .json-formatter-container {
      height: calc(100vh - var(--sidebar-height, 40px));
      padding: 6px;
    }

    .input-area {
      max-width: 100%;
      margin: 0;
      gap: 6px;
    }
    
    /* ç§»åŠ¨ç«¯è¾“å‡ºåŒºåŸŸå±•å¼€æ—¶ï¼Œè¾“å…¥åŒºåŸŸä¿æŒ100%å®½åº¦ */
    .editor-workspace:has(.output-area.expanded) .input-area {
      max-width: 100%;
    }
    
    /* ä¼˜åŒ–ç§»åŠ¨ç«¯æŒ‰é’®ç»„å¸ƒå±€ */
    .output-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-auto-flow: dense;
      gap: 4px 6px;
      flex-wrap: wrap;
    }

    .output-controls button,
    .output-controls select {
      flex: 0 0 auto;
      min-width: fit-content;
      padding: 6px 8px;
      font-size: 11px;
      white-space: nowrap;
      max-width: none;
    }

    /* æœ€åä¸‰ä¸ªæŒ‰é’®ï¼ˆæ¸…ç©ºã€å†å²è®°å½•ã€å­—ä½“å¤§å°é€‰æ‹©ï¼‰åœ¨ç§»åŠ¨ç«¯å°å±å¹•æƒ…å†µä¸‹å¹¶æ’æ˜¾ç¤º */
    #clear-btn,
    #history-btn,
    #font-size-select {
      grid-column: auto;
      grid-row: span 1;
      flex: 1;
      width: auto;
      min-width: 0;
    }
  }

  .input-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .section-label {
    font-size: 0.875rem;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    flex-shrink: 0;
  }

  /* H1æ ‡ç­¾æ ·å¼é‡ç½®ï¼Œä¿æŒå¸ƒå±€ä¸€è‡´ */
  h1.section-label {
    margin: 0;
    padding: 4px 0 6px 0;
    font-size: 1rem;
    font-weight: 700;
    color: #0f172a;
    flex-shrink: 0;
    display: block;
  }

  h2.section-label {
    margin: 0;
    padding: 0;
    font-size: 0.85rem;
    font-weight: 600;
    margin-top: 10px;
  }

  /* Section Header Row - æ ‡é¢˜å’Œæç¤ºåœ¨åŒä¸€è¡Œ */
  .section-header-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  /* Editor Hint Inline - å†…è”æç¤º */
  .editor-hint-inline {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(37, 99, 235, 0.08) 100%);
    border: 1px solid rgba(59, 130, 246, 0.2);
    border-radius: 6px;
    padding: 4px 10px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    flex-shrink: 0;
  }

  .editor-hint-inline:hover {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.12) 0%, rgba(37, 99, 235, 0.12) 100%);
    border-color: rgba(59, 130, 246, 0.3);
    box-shadow: 0 1px 4px rgba(59, 130, 246, 0.1);
  }

  .editor-hint-inline.hint-hidden {
    opacity: 0;
    transform: translateX(4px);
    pointer-events: none;
  }

  .editor-hint-inline .hint-icon {
    font-size: 14px;
    flex-shrink: 0;
    animation: sparkle 2s ease-in-out infinite;
  }

  @keyframes sparkle {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }

  .editor-hint-inline .hint-text {
    font-size: 0.75rem;
    font-weight: 600;
    color: #3b82f6;
    white-space: nowrap;
  }

  /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
  @media (max-width: 768px) {
    .section-header-row {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }

    .editor-hint-inline {
      padding: 3px 8px;
    }

    .editor-hint-inline .hint-icon {
      font-size: 12px;
    }

    .editor-hint-inline .hint-text {
      font-size: 0.7rem;
    }
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹çš„æ ‡é¢˜ä¼˜åŒ– */
  .editors-wrapper.compare-mode h1.section-label,
  .editors-wrapper.compare-mode h2.section-label {
    margin-top: 0;
    margin-bottom: 6px;
    text-align: center;
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹æ·»åŠ è¾¹æ¡†åŒºåˆ†ä¸¤ä¸ªç¼–è¾‘å™¨ */
  .editors-wrapper.compare-mode .input-section:first-child .input-editor-wrapper {
    border: 2px solid #3b82f6;
  }

  .editors-wrapper.compare-mode .compare-editor .input-editor-wrapper {
    border: 2px solid #10b981;
  }

  /* æ¯”è¾ƒæ¨¡å¼æ ·å¼ */
  .compare-editor {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .compare-editor.hidden {
    display: none;
  }

  /* ç¼–è¾‘å™¨åŒ…è£…å®¹å™¨ */
  .editors-wrapper {
    display: flex;
    flex: 1;
    gap: 0;
    min-height: 0;
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹çš„å¸ƒå±€è°ƒæ•´ */
  .editors-wrapper.compare-mode {
    gap: 10px;
  }

  .editors-wrapper.compare-mode .input-section {
    flex: 1;
    min-height: 0;
    min-width: 0;
  }

  .editors-wrapper.compare-mode .compare-editor {
    flex: 1;
    min-height: 0;
    min-width: 0;
  }

  /* ç§»åŠ¨ç«¯æ¯”è¾ƒæ¨¡å¼ä¿æŒä¸Šä¸‹ç»“æ„ */
  @media (max-width: 768px) {
    .editors-wrapper.compare-mode {
      flex-direction: column;
      gap: 8px;
    }
    
    .editors-wrapper.compare-mode .input-section,
    .editors-wrapper.compare-mode .compare-editor {
      min-height: 200px;
    }
    
    /* è°ƒæ•´æ¯”è¾ƒæ¨¡å¼ä¸‹ç¼–è¾‘å™¨å®¹å™¨çš„é«˜åº¦ */
    .editors-wrapper.compare-mode .monaco-editor-container {
      min-height: 200px;
    }
    
    /* ä¼˜åŒ–ç§»åŠ¨ç«¯æ¯”è¾ƒæ¨¡å¼ä¸‹çš„æ ‡é¢˜æ˜¾ç¤º */
    .editors-wrapper.compare-mode .section-label {
      font-size: 0.75rem;
      margin-bottom: 4px;
    }
  }

  /* Diffç»“æœæ ·å¼ */
  .diff-result {
    padding: 16px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 13px;
    line-height: 1.6;
    overflow: auto;
  }

  .diff-added {
    background-color: #d4edda;
    color: #155724;
    padding: 4px 8px;
    margin: 2px 0;
    border-left: 3px solid #28a745;
  }

  .diff-removed {
    background-color: #f8d7da;
    color: #721c24;
    padding: 4px 8px;
    margin: 2px 0;
    border-left: 3px solid #dc3545;
    text-decoration: line-through;
  }

  .diff-changed {
    background-color: #fff3cd;
    color: #856404;
    padding: 4px 8px;
    margin: 2px 0;
    border-left: 3px solid #ffc107;
  }

  .diff-unchanged {
    color: #6c757d;
    padding: 4px 8px;
    margin: 2px 0;
  }

  /* Monaco Editorå·®å¼‚é«˜äº®è£…é¥° - ä½¿ç”¨Monacoå†…ç½®çš„è£…é¥°ç±» */
  .monaco-editor .diff-removed {
    background-color: rgba(239, 68, 68, 0.6) !important;
    border-left: 4px solid #ef4444 !important;
  }

  .monaco-editor .diff-added {
    background-color: rgba(34, 197, 94, 0.6) !important;
    border-left: 4px solid #22c55e !important;
  }

  .monaco-editor .diff-changed {
    background-color: rgba(234, 179, 8, 0.6) !important;
    border-left: 4px solid #eab308 !important;
  }

  .input-editor-wrapper {
    display: flex;
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    overflow: hidden;
    flex: 1;
    min-height: 0;
    position: relative;
  }

  .monaco-editor-container {
    flex: 1;
    width: 100%;
    height: 100%;
    min-height: 400px;
    position: relative;
  }

  /* ç¾åŒ–Monaco EditoræŠ˜å æŒ‰é’® */
  .monaco-editor .codicon-add-selection,
  .monaco-editor .codicon-chevron-right,
  .monaco-editor .folding-icon::before,
  .monaco-editor .codicon-folding-expanded,
  .monaco-editor .codicon-folding-collapsed {
    content: '' !important;
  }

  /* è‡ªå®šä¹‰æŠ˜å æŒ‰é’®æ ·å¼ */
  .monaco-editor .folding-icon {
    width: 16px !important;
    height: 16px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
  }

  /* å±•å¼€çŠ¶æ€çš„æŠ˜å æŒ‰é’® */
  .monaco-editor .folding-icon.collapsed::after,
  .monaco-editor .codicon-folding-collapsed::after {
    content: 'â–¶' !important;
    font-size: 10px !important;
    color: #6b7280 !important;
    display: inline-block !important;
    margin-left: 1px !important;
  }

  /* æŠ˜å çŠ¶æ€çš„æŠ˜å æŒ‰é’® */
  .monaco-editor .folding-icon:not(.collapsed)::after,
  .monaco-editor .codicon-folding-expanded::after {
    content: 'â–¼' !important;
    font-size: 9px !important;
    color: #6b7280 !important;
    display: inline-block !important;
  }

  /* æŠ˜å æŒ‰é’®hoveræ•ˆæœ */
  .monaco-editor .folding-icon:hover::after {
    color: #3b82f6 !important;
  }

  /* JSON æ ¡éªŒé”™è¯¯æç¤º */
  .validation-error {
    padding: 12px 16px;
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    border: 1px solid #fecaca;
    border-radius: 6px;
    margin-bottom: 10px;
    font-size: 0.875rem;
    color: #991b1b;
    border-left: 4px solid #ef4444;
    display: none;
    animation: slideDown 0.3s ease-out;
  }

  .validation-error.show {
    display: block;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* æå–åŒºåŸŸ */
  .extraction-section {
    padding: 10px 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
    border-radius: 6px;
    border: 1px solid #e9ecef;
  }

  .extraction-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .extraction-controls label {
    font-weight: 600;
    color: var(--text-color);
    white-space: nowrap;
    font-size: 0.85rem;
  }

  .extraction-controls input {
    flex: 1;
    min-width: 200px;
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    font-size: 13px;
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: all 0.2s;
  }

  .extraction-controls input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .extraction-controls button {
    padding: 6px 14px;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s;
  }

  #apply-extract {
    font-size: 13px;
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  }

  #apply-extract:hover {
    background: linear-gradient(135deg, #059669 0%, #047857 100%);
    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
  }

  .extraction-controls button:hover {
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    transform: translateY(-1px);
  }

  #clear-extract-fn {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    font-size: 13px;
  }

  #clear-extract-fn:hover {
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  }

  /* æŒ‰é’®ç»„ */
  .output-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .output-controls button {
    padding: 6px 10px;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 11px;
    font-weight: 500;
    transition: all 0.2s;
    min-width: fit-content;
    flex: 0 0 auto;
    text-align: center;
    white-space: nowrap;
  }

  .output-controls select {
    padding: 6px 10px;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 11px;
    font-weight: 500;
    transition: all 0.2s;
    min-width: fit-content;
    flex: 0 0 auto;
  }

  .output-controls select option {
    background: white;
    color: #1f2937;
    padding: 6px 10px;
  }

  .output-controls select:hover {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    transform: translateY(-1px);
  }

  .output-controls button:hover {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    box-shadow: 0 2px 6px rgba(37, 99, 235, 0.3);
    transform: translateY(-1px);
  }

  #clear-btn {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
  }

  #clear-btn:hover {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important;
    box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3);
  }

  /* æŒ‰é’®åˆ†éš”ç¬¦æ ·å¼ */
  .button-separator {
    display: flex;
    align-items: center;
    justify-content: center;
    color: #9ca3af;
    font-weight: bold;
    padding: 0 4px;
    user-select: none;
  }

  @media (max-width: 768px) {
    .button-separator {
      display: none; /* ç§»åŠ¨ç«¯éšè—åˆ†éš”ç¬¦ */
    }
  }

  /* JSONè¡¨æ ¼æ ·å¼ */
  .json-table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
    font-size: 14px;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  .json-table thead {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
  }

  .json-table th {
    padding: 12px 16px;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid #e5e7eb;
  }

  .json-table td {
    padding: 10px 16px;
    border-bottom: 1px solid #f3f4f6;
  }

  .json-table tbody tr:hover {
    background-color: #f9fafb;
  }

  .json-table tbody tr:last-child td {
    border-bottom: none;
  }

  .json-table .key-column {
    background-color: #f9fafb;
    font-weight: 600;
    width: 30%;
    border-right: 1px solid #e5e7eb;
  }

  .json-table .inline-code {
    background-color: #f3f4f6;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 12px;
    color: #1f2937;
    display: inline-block;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .json-table .number {
    color: #ef4444;
    font-weight: 600;
  }

  .json-table .boolean-true {
    color: #10b981;
    font-weight: 600;
  }

  .json-table .boolean-false {
    color: #ef4444;
    font-weight: 600;
  }

  .table-output {
    width: 100%;
    height: 100%;
    overflow: auto;
  }

  /* ç§»åŠ¨ç«¯æŒ‰é’®å¸ƒå±€ä¼˜åŒ– */
  @media (max-width: 768px) {
    .output-controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px 8px;
    }

    .output-controls button,
    .output-controls select {
      font-size: 11px;
      padding: 8px 6px;
      min-height: 36px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }

  @media (max-width: 480px) {
    .output-controls {
      grid-template-columns: repeat(2, 1fr);
      gap: 5px 6px;
    }

    .output-controls button,
    .output-controls select {
      font-size: 10px;
      padding: 7px 5px;
      min-height: 34px;
    }
  }

  /* å³ä¾§è¾“å‡ºåŒºåŸŸ */
  .output-area {
    width: 0;
    opacity: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 1px solid transparent;
  }

  .output-area.expanded {
    width: 50%;
    opacity: 1;
    border-left: 1px solid #e5e7eb;
    padding-left: 0;
  }

  .output-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
    border-radius: 6px 6px 0 0;
    border: 1px solid #e9ecef;
    border-bottom: none;
  }

  .output-title {
    font-size: 0.85rem;
    font-weight: 600;
    color: #6b7280;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .close-output-btn {
    background: none;
    border: none;
    font-size: 24px;
    color: #9ca3af;
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s;
    line-height: 1;
  }

  .close-output-btn:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #dc2626;
  }

  /* è¾“å‡ºå†…å®¹åŒºåŸŸï¼Œä¸è¾“å…¥æ¡†ç›¸åŒæ ·å¼ */
  .output-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .output-editor-wrapper {
    display: flex;
    border: 1px solid #e1e4e8;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
    flex: 1;
    background: linear-gradient(to bottom, #fafbfc 0%, #f5f6f8 100%);
  }

  #output-json {
    flex: 1;
    padding: 12px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 13px;
    line-height: 1.5;
    overflow: auto;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    min-height: 0;
  }

  /* JSONæ ‘å½¢æŸ¥çœ‹å™¨æ ·å¼ */
  .json-root {
    padding: 5px 0;
  }

  .json-bracket {
    padding: 0 5px;
  }

  .json-node {
    margin-left: 18px;
  }

  .json-property {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 2px 0;
    border-radius: 3px;
    transition: background 0.1s;
  }

  .json-property:hover {
    background: rgba(59, 130, 246, 0.05);
  }

  .json-toggle {
    display: inline-block;
    width: 14px;
    height: 14px;
    text-align: center;
    line-height: 12px;
    cursor: pointer;
    border: 1px solid #d1d5db;
    border-radius: 3px;
    margin-right: 6px;
    font-size: 10px;
    user-select: none;
    background: #fff;
    color: #6b7280;
    transition: all 0.15s;
  }

  .json-toggle:hover {
    border-color: #3b82f6;
    color: #3b82f6;
  }

  .json-key {
    color: #7c3aed;
    margin-right: 6px;
    font-weight: 500;
  }

  .json-separator {
    margin-right: 6px;
    color: #94a3b8;
  }

  .json-value-string {
    color: #059669;
  }

  .json-value-number {
    color: #dc2626;
  }

  .json-value-boolean {
    color: #2563eb;
  }

  .json-value-null {
    color: #9ca3af;
  }

  .json-value-object,
  .json-value-array {
    color: #1f2937;
  }

  .collapsed > .json-node {
    display: none;
  }

  /* Tutorial Section */
  .tutorial-section {
    max-width: 1800px;
    margin: 60px auto 0;
    padding: 40px 20px;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .tutorial-section .section-header,
  .faq-section .section-header {
    text-align: center;
    margin-bottom: 40px;
  }

  .tutorial-section .section-header h2,
  .faq-section .section-header h2 {
    font-size: 2.5rem;
    font-weight: 800;
    color: #1e293b;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .tutorial-section .section-header p,
  .faq-section .section-header p {
    font-size: 1.1rem;
    color: #64748b;
  }

  .tutorial-container {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 32px;
  }

  .tutorial-step {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    background: white;
    padding: 24px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 4px solid transparent;
  }

  .tutorial-step:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    border-left-color: #3b82f6;
  }

  .step-number {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 1.125rem;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }

  .step-content {
    flex: 1;
  }

  .step-content h3 {
    font-size: 1.25rem;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .step-content p {
    color: #475569;
    line-height: 1.7;
    margin-bottom: 12px;
    font-size: 0.9375rem;
  }

  .step-content p:last-child {
    margin-bottom: 0;
  }

  .step-example {
    background: #1e293b;
    border-radius: 8px;
    padding: 16px;
    margin: 12px 0;
    overflow-x: auto;
  }

  .step-example code {
    color: #e2e8f0;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.6;
    white-space: pre;
  }

  .example-desc {
    color: #64748b;
    font-size: 0.875rem;
    font-style: italic;
    margin-top: 8px;
  }

  .tip {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border-left: 4px solid #f59e0b;
    padding: 12px 16px;
    border-radius: 6px;
    margin-top: 12px;
    font-size: 0.875rem;
    color: #92400e;
  }

  .privacy-note {
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border-left: 4px solid #3b82f6;
    padding: 12px 16px;
    border-radius: 6px;
    margin-top: 12px;
    font-size: 0.875rem;
    color: #1e40af;
  }

  .action-list {
    list-style: none;
    padding: 0;
    margin: 12px 0 0 0;
  }

  .action-list li {
    padding: 8px 0;
    padding-left: 24px;
    position: relative;
    color: #475569;
    font-size: 0.9375rem;
    line-height: 1.6;
  }

  .action-list li::before {
    content: 'âœ“';
    position: absolute;
    left: 0;
    color: #3b82f6;
    font-weight: 700;
  }

  .action-list li strong {
    color: #0f172a;
    font-weight: 600;
  }

  /* Features Section - åˆ›æ„æ¸å˜æ•ˆæœ */
  .features-section {
    max-width: 1800px;
    margin: 60px auto 0;
    padding: 60px 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 20px;
    position: relative;
    overflow: hidden;
  }

  .features-section::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
    animation: rotate 20s linear infinite;
  }

  @keyframes rotate {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  .features-section .section-header {
    text-align: center;
    margin-bottom: 50px;
    position: relative;
    z-index: 1;
  }

  .features-section .section-header h2 {
    font-size: 2.5rem;
    font-weight: 800;
    color: white;
    margin-bottom: 12px;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  }

  .features-section .section-header p {
    font-size: 1.1rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .features-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 30px;
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    z-index: 1;
  }

  .feature-item {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 0;
    position: relative;
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  }

  .feature-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .feature-item:hover::before {
    transform: scaleX(1);
  }

  .feature-item:hover {
    transform: translateY(-8px) rotateX(2deg);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
  }

  .feature-number {
    font-size: 4rem;
    font-weight: 900;
    color: rgba(102, 126, 234, 0.08);
    position: absolute;
    top: -10px;
    right: 10px;
    line-height: 1;
    transition: all 0.4s ease;
  }

  .feature-item:hover .feature-number {
    color: rgba(102, 126, 234, 0.15);
    transform: scale(1.1);
  }

  .feature-content {
    padding: 32px;
    position: relative;
    z-index: 1;
  }

  .feature-icon {
    font-size: 3rem;
    margin-bottom: 20px;
    display: inline-block;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
  }

  .feature-item:hover .feature-icon {
    transform: scale(1.2) rotate(5deg);
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
  }

  .feature-content h3 {
    font-size: 1.35rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 12px;
    transition: color 0.3s ease;
  }

  .feature-item:hover .feature-content h3 {
    color: #667eea;
  }

  .feature-content p {
    color: #64748b;
    line-height: 1.7;
    font-size: 0.95rem;
  }

  /* æ”¯æŒçš„åŠŸèƒ½ Section */
  .supported-formats-section {
    max-width: 1800px;
    margin: 60px auto 0;
    padding: 50px 20px;
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
  }

  .supported-formats-section .section-header {
    text-align: center;
    margin-bottom: 45px;
  }

  .supported-formats-section .section-header h2 {
    font-size: 2.2rem;
    font-weight: 800;
    color: #0f172a;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .supported-formats-section .section-header p {
    font-size: 1.1rem;
    color: #64748b;
  }

  .formats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 24px;
    max-width: 1200px;
    margin: 0 auto;
  }

  .format-category {
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid #e0f2fe;
  }

  .format-category:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(14, 165, 233, 0.15);
    border-color: #0ea5e9;
  }

  .format-category h3 {
    font-size: 1.2rem;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #e0f2fe;
  }

  .format-category ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .format-category li {
    padding: 8px 0;
    padding-left: 24px;
    position: relative;
    color: #475569;
    font-size: 0.9rem;
    line-height: 1.6;
  }

  .format-category li::before {
    content: 'âœ“';
    position: absolute;
    left: 0;
    color: #0ea5e9;
    font-weight: 700;
  }

  .formats-note {
    max-width: 900px;
    margin: 35px auto 0;
    padding: 18px 24px;
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border-left: 4px solid #3b82f6;
    border-radius: 8px;
    font-size: 0.95rem;
    color: #1e40af;
    line-height: 1.7;
  }

  .formats-note strong {
    font-weight: 700;
    color: #1e3a8a;
  }

  /* FAQ Section - 2åˆ—å±•å¼€æ ·å¼ */
  .faq-section {
    max-width: 1800px;
    margin: 60px auto 40px;
    padding: 40px 20px;
    background: transparent;
    border-radius: 0;
    border: none;
  }

  .faq-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 32px;
    max-width: 1200px;
    margin: 0 auto;
  }

  .faq-item {
    padding: 0;
    background: transparent;
    border-radius: 0;
    border: none;
    border-left: 3px solid #3b82f6;
    padding-left: 20px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .faq-item:hover {
    border-left-color: #2563eb;
    padding-left: 24px;
  }

  .faq-item h3 {
    font-size: 1.15rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 12px;
  }

  .faq-item p {
    color: #64748b;
    line-height: 1.7;
    font-size: 0.95rem;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 1200px) {
    .output-area.expanded {
      width: 60%;
    }
  }

  @media (max-width: 768px) {
    .json-formatter-container {
      padding: 6px;
      height: calc(100vh - var(--sidebar-height, 40px));
      flex-shrink: 0;
    }

    .editor-workspace {
      flex-direction: column;
    }

    .input-area {
      gap: 6px;
      min-height: 180px;
    }

    .monaco-editor-container {
      min-height: 150px;
    }

    .extraction-controls {
      flex-wrap: wrap;
    }

    .extraction-controls input {
      min-width: 100%;
    }

    .output-area.expanded {
      width: 100%;
      border-left: none;
      padding-left: 0;
      margin-top: 12px;
      height: 300px;
    }

    /* Tutorial section ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .tutorial-step {
      flex-direction: column;
      padding: 16px;
    }

    .step-number {
      margin-bottom: 12px;
    }

    .section-header {
      padding: 20px 12px;
    }

    .section-header h2 {
      font-size: 1.5rem;
    }

    /* Features ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .features-grid {
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 12px;
    }

    /* Supported Formats ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .formats-grid {
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 12px;
    }

    .format-category {
      padding: 18px;
    }

    .formats-note {
      margin: 25px 12px 0;
      padding: 14px 18px;
      font-size: 0.9rem;
    }

    /* FAQ ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .faq-grid {
      grid-template-columns: 1fr;
      gap: 24px;
      padding: 0 12px;
    }

    .faq-item {
      border-left-width: 2px;
      padding-left: 16px;
    }

    .faq-item:hover {
      padding-left: 18px;
    }
  }

  @media (max-width: 480px) {
    .json-formatter-container {
      padding: 6px;
    }

    .json-action-group {
      flex: 1;
    }

    .json-input {
      min-height: 150px;
      font-size: 12px;
    }

    .extraction-section {
      padding: 8px;
    }
  }
</style>

<script type="module">
  // é…ç½® Monaco Editor çš„èµ„æºè·¯å¾„
  window.MonacoEnvironment = {
    getWorkerUrl: function (workerId, label) {
      return `https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/base/workers/${label === 'json' ? 'json.worker' : 'editor.worker'}.js`;
    }
  };

  // ä½¿ç”¨ CDN å¯¼å…¥ Monaco Editor
  import * as monaco from 'https://esm.sh/monaco-editor@0.45.0';

  // é…ç½® Monaco Editor
  monaco.editor.setTheme('vs');

  // å…¨å±€å˜é‡
  let editor = null;
  let outputEditor = null;
  let compareEditor = null;
  let translations = {};
  let isCompareMode = false;
  let leftDecorations = [];
  let rightDecorations = [];

  // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
  document.addEventListener('DOMContentLoaded', () => {
    // ä»DOMå…ƒç´ è·å–ç¿»è¯‘æ–‡æœ¬
    const container = document.querySelector('.json-formatter-container');
    translations = {
      enterExtractionFn: container.dataset.enterExtractionFn,
      enterData: container.dataset.enterData,
      extractionError: container.dataset.extractionError,
      parsingError: container.dataset.parsingError,
      compressSuccess: container.dataset.compressSuccess,
      escapeSuccess: container.dataset.escapeSuccess,
      xmlSuccess: container.dataset.xmlSuccess,
      tsSuccess: container.dataset.tsSuccess,
      csvSuccess: container.dataset.csvSuccess,
      excelSuccess: container.dataset.excelSuccess
    };

    // åˆå§‹åŒ– Monaco Editor
    initializeMonacoEditor();

    initializeJsonFormatter();
  });

  // åˆå§‹åŒ– Monaco Editor
  function initializeMonacoEditor() {
    const container = document.getElementById('monaco-editor-container');
    if (!container) {
      console.error('Monaco Editor container not found');
      return;
    }

    // ç­‰å¾…é¡µé¢å®Œå…¨æ¸²æŸ“ï¼ŒåŒ…æ‹¬ CSS æ ·å¼åº”ç”¨
    // ä½¿ç”¨åŒé‡ requestAnimationFrame ç¡®ä¿æµè§ˆå™¨å®Œæˆå¸ƒå±€è®¡ç®—
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        // ç¡®ä¿å®¹å™¨æœ‰æ­£ç¡®çš„å°ºå¯¸
        console.log('Container dimensions:', {
          width: container.offsetWidth,
          height: container.offsetHeight
        });

        // å¦‚æœå®¹å™¨å°ºå¯¸è¿˜æ˜¯å¼‚å¸¸ï¼Œå†å»¶è¿Ÿä¸€ç‚¹
        if (container.offsetWidth === 0 || container.offsetHeight === 0) {
          setTimeout(() => createEditor(container), 50);
        } else {
          createEditor(container);
        }
      });
    });
  }

  // åˆ›å»º Monaco Editor
  function createEditor(container) {
    // è·å–ä¿å­˜çš„å­—ä½“å¤§å°
    const savedFontSize = localStorage.getItem('editorFontSize') || '13';

    // åˆ›å»ºè¾“å…¥ç¼–è¾‘å™¨
    editor = monaco.editor.create(container, {
      value: '',
      language: 'json',
      theme: 'vs',
      automaticLayout: true,
      fontSize: parseInt(savedFontSize),
      fontFamily: "'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
      lineHeight: 21,
      minimap: { enabled: false },
      scrollBeyondLastLine: false,
      wordWrap: 'off',
      // è¡Œå·é…ç½®
      lineNumbers: 'on',
      lineNumbersMinChars: 3,
      // æŠ˜å é…ç½®
      folding: true,
      foldingStrategy: 'indentation',
      foldingHighlight: true,
      showFoldingControls: 'always',
      // å…¶ä»–é…ç½®
      matchBrackets: 'always',
      autoClosingBrackets: 'always',
      autoClosingQuotes: 'always',
      formatOnPaste: true,
      formatOnType: true,
      tabSize: 2,
      renderLineHighlight: 'all',
      scrollbar: {
        vertical: 'visible',
        horizontal: 'visible'
      },
      padding: { top: 12, bottom: 12 },
      readOnly: false
    });

    console.log('Monaco Editor created successfully');

    // åˆ›å»ºè¾“å‡ºç¼–è¾‘å™¨
    const outputContainer = document.getElementById('output-monaco-container');
    if (outputContainer) {
      outputEditor = monaco.editor.create(outputContainer, {
        value: '',
        language: 'json',
        theme: 'vs',
        automaticLayout: true,
        fontSize: parseInt(savedFontSize),
        fontFamily: "'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
        lineHeight: 21,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        wordWrap: 'off',
        lineNumbers: 'on',
        lineNumbersMinChars: 3,
        folding: true,
        foldingStrategy: 'indentation',
        foldingHighlight: true,
        showFoldingControls: 'always',
        matchBrackets: 'always',
        tabSize: 2,
        renderLineHighlight: 'all',
        scrollbar: {
          vertical: 'visible',
          horizontal: 'visible'
        },
        padding: { top: 12, bottom: 12 },
        readOnly: true  // è¾“å‡ºç¼–è¾‘å™¨åªè¯»
      });
      console.log('Output Monaco Editor created successfully');
    }

    // åˆ›å»ºæ¯”è¾ƒç¼–è¾‘å™¨
    const compareContainer = document.getElementById('monaco-compare-container');
    if (compareContainer) {
      compareEditor = monaco.editor.create(compareContainer, {
        value: '',
        language: 'json',
        theme: 'vs',
        automaticLayout: true,
        fontSize: parseInt(savedFontSize),
        fontFamily: "'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
        lineHeight: 21,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        wordWrap: 'off',
        lineNumbers: 'on',
        lineNumbersMinChars: 3,
        folding: true,
        foldingStrategy: 'indentation',
        foldingHighlight: true,
        showFoldingControls: 'always',
        matchBrackets: 'always',
        autoClosingBrackets: 'always',
        autoClosingQuotes: 'always',
        formatOnPaste: true,
        formatOnType: true,
        tabSize: 2,
        renderLineHighlight: 'all',
        scrollbar: {
          vertical: 'visible',
          horizontal: 'visible'
        },
        padding: { top: 12, bottom: 12 },
        readOnly: false
      });
      console.log('Compare Monaco Editor created successfully');

      // ç›‘å¬æ¯”è¾ƒç¼–è¾‘å™¨å†…å®¹å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°å·®å¼‚é«˜äº®
      compareEditor.onDidChangeModelContent(() => {
        if (isCompareMode) {
          highlightDifferences();
        }
      });
    }

    // è°ƒè¯•ï¼šæ£€æŸ¥ DOM ç»“æ„
    setTimeout(() => {
      const monacoContainer = container.querySelector('.monaco-editor');
      if (monacoContainer) {
        const margin = monacoContainer.querySelector('.margin');
        console.log('Monaco DOM structure:', {
          container: container.offsetWidth,
          monacoEditor: monacoContainer.offsetWidth,
          margin: margin ? margin.offsetWidth : 'NOT FOUND',
          marginVisible: margin ? window.getComputedStyle(margin).display : 'N/A'
        });
      }
    }, 200);

    // å¼ºåˆ¶æ›´æ–°å¸ƒå±€
    setTimeout(() => {
      if (editor) {
        editor.layout();
        console.log('Monaco Editor layout updated');
      }
    }, 100);

    // ç›‘å¬å†…å®¹å˜åŒ–ï¼Œè‡ªåŠ¨æ ¼å¼åŒ–å’Œä¿å­˜å†å²
    editor.onDidChangeModelContent(() => {
      clearTimeout(window.autoFormatTimeout);
      window.autoFormatTimeout = setTimeout(autoFormatJson, 500);

      // å¦‚æœåœ¨æ¯”è¾ƒæ¨¡å¼ï¼Œæ›´æ–°å·®å¼‚é«˜äº®
      if (isCompareMode) {
        highlightDifferences();
      }

      // æ§åˆ¶æç¤ºæ˜¾ç¤º/éšè—
      const hint = document.getElementById('editor-hint');
      if (hint) {
        const hasContent = getEditorContent().trim().length > 0;
        if (hasContent) {
          hint.classList.add('hint-hidden');
        } else {
          hint.classList.remove('hint-hidden');
        }
      }
    });

    // ç›‘å¬ JSON é”™è¯¯æ ‡è®°å˜åŒ–
    monaco.editor.onDidChangeMarkers(() => {
      const errorElement = document.getElementById('json-validation-error');
      if (!errorElement) return;

      const model = editor.getModel();
      if (!model) return;

      const modelMarkers = model.getAllMarkers();
      if (modelMarkers.length === 0) {
        // æ²¡æœ‰é”™è¯¯ï¼Œéšè—æç¤º
        errorElement.classList.remove('show');
        errorElement.textContent = '';
      } else {
        // æœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªé”™è¯¯
        const firstError = modelMarkers[0];
        const errorInfo = firstError.message;

        // è·å–å½“å‰è¯­è¨€
        const currentLang = window.appState.lang || 'zh';
        const errorMessage = currentLang === 'zh'
          ? `ç¬¬ ${firstError.startLineNumber} è¡Œé”™è¯¯ï¼š${errorInfo}`
          : `Line ${firstError.startLineNumber} error: ${errorInfo}`;

        errorElement.textContent = errorMessage;
        errorElement.classList.add('show');
      }
    });
  }

  // è·å–ç¼–è¾‘å™¨ä¸­çš„æ–‡æœ¬
  function getEditorContent() {
    return editor ? editor.getValue() : '';
  }

  // è®¾ç½®ç¼–è¾‘å™¨ä¸­çš„æ–‡æœ¬
  function setEditorContent(content) {
    if (editor) {
      editor.setValue(content);
    }
  }

  // ============ è¾“å…¥ç±»å‹æ£€æµ‹å’Œè§£æå‡½æ•° ============

  // æ£€æµ‹è¾“å…¥ç±»å‹
  function detectInputType(inputText) {
    const trimmed = inputText.trim();

    // æ£€æµ‹æ˜¯å¦ä¸ºURLå‚æ•°
    if (trimmed.includes('?') || /^\w+=/.test(trimmed)) {
      return 'urlparams';
    }

    // æ£€æµ‹æ˜¯å¦ä¸ºXML
    if (trimmed.startsWith('<?xml') || trimmed.startsWith('<!DOCTYPE') || /^<[\w-]+/.test(trimmed)) {
      return 'xml';
    }

    // æ£€æµ‹æ˜¯å¦ä¸ºYAML
    if (/^[\w-]+:\s*\n/.test(trimmed) || /^[\w-]+:\s*\S+/.test(trimmed)) {
      // ç®€å•çš„YAMLç‰¹å¾ï¼šåŒ…å«é”®å€¼å¯¹ï¼Œä½¿ç”¨å†’å·åˆ†éš”
      // æ’é™¤JSONï¼ˆJSONå·²ç»è¢«JSON.parseå¤„ç†è¿‡äº†ï¼‰
      try {
        JSON.parse(trimmed);
        return 'json';
      } catch {
        return 'yaml';
      }
    }

    // é»˜è®¤å°è¯•JSON
    return 'json';
  }

  // è§£æURLå‚æ•°ä¸ºJSONå¯¹è±¡
  function parseUrlParams(inputText) {
    const result = {};

    // ç§»é™¤URLå‰é¢çš„éƒ¨åˆ†ï¼Œåªä¿ç•™æŸ¥è¯¢å­—ç¬¦ä¸²
    let queryString = inputText.trim();
    const questionMarkIndex = queryString.indexOf('?');
    if (questionMarkIndex !== -1) {
      queryString = queryString.substring(questionMarkIndex + 1);
    }

    // åˆ†å‰²å‚æ•°
    const pairs = queryString.split('&');

    for (const pair of pairs) {
      if (!pair) continue;

      let [key, value] = pair.split('=');

      // è§£ç URLç¼–ç 
      if (key) {
        key = decodeURIComponent(key.replace(/\+/g, ' '));
      }
      if (value !== undefined) {
        value = decodeURIComponent(value.replace(/\+/g, ' '));
      } else {
        value = '';
      }

      // å°è¯•å°†å€¼è½¬æ¢ä¸ºæ•°å­—æˆ–å¸ƒå°”å€¼
      if (value === 'true') {
        value = true;
      } else if (value === 'false') {
        value = false;
      } else if (!isNaN(value) && value !== '') {
        const num = parseFloat(value);
        if (!isNaN(num)) {
          value = num;
        }
      }

      // å¤„ç†é‡å¤çš„é”®ï¼ˆè½¬æ¢ä¸ºæ•°ç»„ï¼‰
      if (key in result) {
        if (!Array.isArray(result[key])) {
          result[key] = [result[key]];
        }
        result[key].push(value);
      } else {
        result[key] = value;
      }
    }

    return result;
  }

  // è§£æXMLä¸ºJSONå¯¹è±¡
  function parseXml(inputText) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(inputText, 'text/xml');

    // æ£€æŸ¥è§£æé”™è¯¯
    const parseError = xmlDoc.getElementsByTagName('parsererror');
    if (parseError.length > 0) {
      throw new Error('Invalid XML format');
    }

    // é€’å½’è½¬æ¢XMLèŠ‚ç‚¹ä¸ºJSON
    function xmlTojson(node) {
      // æ–‡æœ¬èŠ‚ç‚¹
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        return text;
      }

      // å…ƒç´ èŠ‚ç‚¹
      if (node.nodeType === Node.ELEMENT_NODE) {
        const obj = {};

        // å¤„ç†å±æ€§
        if (node.attributes) {
          for (let i = 0; i < node.attributes.length; i++) {
            const attr = node.attributes[i];
            obj['@' + attr.name] = attr.value;
          }
        }

        // å¤„ç†å­èŠ‚ç‚¹
        const children = {};
        let hasChildren = false;

        for (let i = 0; i < node.childNodes.length; i++) {
          const child = node.childNodes[i];

          if (child.nodeType === Node.TEXT_NODE) {
            const text = child.textContent.trim();
            if (text) {
              // å¦‚æœåªæœ‰æ–‡æœ¬å†…å®¹ï¼Œç›´æ¥è¿”å›
              if (Object.keys(obj).length === 0) {
                return text;
              }
              obj['#text'] = text;
            }
          } else if (child.nodeType === Node.ELEMENT_NODE) {
            hasChildren = true;
            const childName = child.nodeName;
            const childValue = xmlTojson(child);

            if (childName in children) {
              // é‡å¤çš„èŠ‚ç‚¹è½¬æ¢ä¸ºæ•°ç»„
              if (!Array.isArray(children[childName])) {
                children[childName] = [children[childName]];
              }
              children[childName].push(childValue);
            } else {
              children[childName] = childValue;
            }
          }
        }

        // åˆå¹¶å±æ€§å’Œå­èŠ‚ç‚¹
        if (hasChildren) {
          Object.assign(obj, children);
        }

        // å¦‚æœåªæœ‰å±æ€§ï¼Œè¿”å›å¯¹è±¡
        // å¦‚æœå±æ€§ä¸ºç©ºä¸”åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œè¿”å›å­èŠ‚ç‚¹
        if (Object.keys(obj).length === 0) {
          return null;
        }

        return obj;
      }

      return null;
    }

    // ä»æ ¹å…ƒç´ å¼€å§‹è½¬æ¢
    const rootElement = xmlDoc.documentElement;
    const result = {};
    result[rootElement.nodeName] = xmlTojson(rootElement);

    return result;
  }

  // è§£æYAMLä¸ºJSONå¯¹è±¡ï¼ˆç®€åŒ–ç‰ˆï¼Œæ”¯æŒå¸¸ç”¨YAMLè¯­æ³•ï¼‰
  function parseYaml(inputText) {
    const lines = inputText.split('\n');
    const root = {};
    const stack = [{ obj: root, indent: -1 }];

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      const indent = line.search(/\S/);

      if (indent === -1) continue; // ç©ºè¡Œ

      // å›é€€åˆ°æ­£ç¡®çš„å±‚çº§
      while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
        stack.pop();
      }

      const current = stack[stack.length - 1].obj;

      // ç§»é™¤æ³¨é‡Š
      const commentIndex = line.indexOf('#');
      if (commentIndex !== -1) {
        line = line.substring(0, commentIndex);
      }

      // è§£æé”®å€¼å¯¹
      const colonIndex = line.indexOf(':');
      if (colonIndex === -1) continue;

      const key = line.substring(indent, colonIndex).trim();
      let valueStr = line.substring(colonIndex + 1).trim();

      // å¤„ç†ä¸åŒçš„å€¼ç±»å‹
      let value;
      if (!valueStr || valueStr === '') {
        // ç©ºå€¼ï¼Œå¯èƒ½æ˜¯å¯¹è±¡æˆ–æ•°ç»„çš„å¼€å§‹
        // æ£€æŸ¥ä¸‹ä¸€è¡Œæ¥åˆ¤æ–­
        if (i + 1 < lines.length) {
          const nextLine = lines[i + 1];
          const nextIndent = nextLine.search(/\S/);

          if (nextIndent > indent) {
            // ä¸‹ä¸€è¡Œç¼©è¿›æ›´å¤§ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå¯¹è±¡/æ•°ç»„
            value = nextLine.trim().startsWith('-') ? [] : {};
            stack.push({ obj: value, indent: indent });
          } else {
            value = null;
          }
        } else {
          value = null;
        }
      } else if (valueStr.startsWith('[') && valueStr.endsWith(']')) {
        // å†…è”æ•°ç»„
        try {
          value = JSON.parse(valueStr);
        } catch {
          value = valueStr;
        }
      } else if (valueStr.startsWith('{') && valueStr.endsWith('}')) {
        // å†…è”å¯¹è±¡
        try {
          value = JSON.parse(valueStr);
        } catch {
          value = valueStr;
        }
      } else if (valueStr === 'true' || valueStr === 'false') {
        // å¸ƒå°”å€¼
        value = valueStr === 'true';
      } else if (valueStr === 'null' || valueStr === '~') {
        // nullå€¼
        value = null;
      } else if (valueStr.startsWith('"') || valueStr.startsWith("'")) {
        // å¸¦å¼•å·çš„å­—ç¬¦ä¸²
        value = valueStr.slice(1, -1);
      } else if (!isNaN(valueStr)) {
        // æ•°å­—
        value = parseFloat(valueStr);
      } else if (valueStr.startsWith('|') || valueStr.startsWith('>')) {
        // å¤šè¡Œå­—ç¬¦ä¸²
        let multiLine = '';
        let j = i + 1;
        while (j < lines.length) {
          const nextLine = lines[j];
          const nextIndent = nextLine.search(/\S/);
          if (nextIndent <= indent) break;
          multiLine += (multiLine ? '\n' : '') + nextLine.trim();
          j++;
        }
        value = multiLine;
        i = j - 1;
      } else {
        // æ™®é€šå­—ç¬¦ä¸²
        value = valueStr;
      }

      // å¤„ç†æ•°ç»„é¡¹ï¼ˆä»¥-å¼€å¤´ï¼‰
      if (key.startsWith('-')) {
        const arrayKey = key.substring(1).trim();
        if (!Array.isArray(current)) {
          // è½¬æ¢å½“å‰å¯¹è±¡ä¸ºæ•°ç»„
          const temp = {};
          Object.assign(temp, current);
          const parentArray = [];
          if (Object.keys(temp).length > 0) {
            parentArray.push(temp);
          }
          // è¿™é‡Œéœ€è¦ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼Œç®€åŒ–å¤„ç†
          if (arrayKey) {
            if (Array.isArray(current)) {
              current.push({ [arrayKey]: value });
            } else {
              current[arrayKey] = value;
            }
          } else {
            if (Array.isArray(current)) {
              current.push(value);
            } else {
              const arr = [value];
              Object.assign(current, arr);
            }
          }
        }
      } else {
        current[key] = value;
      }
    }

    return root;
  }

  // è‡ªåŠ¨æ ¼å¼åŒ–å‡½æ•°
  function autoFormatJson() {
    const inputText = getEditorContent().trim();

    if (!inputText) {
      return;
    }

    try {
      // æ£€æµ‹è¾“å…¥ç±»å‹
      const inputType = detectInputType(inputText);

      let parsed;
      let converted = false;

      // æ ¹æ®ç±»å‹è§£æ
      if (inputType === 'json') {
        parsed = JSON.parse(inputText);
      } else if (inputType === 'urlparams') {
        parsed = parseUrlParams(inputText);
        converted = true;
      } else if (inputType === 'xml') {
        parsed = parseXml(inputText);
        converted = true;
      } else if (inputType === 'yaml') {
        parsed = parseYaml(inputText);
        converted = true;
      } else {
        // é»˜è®¤å°è¯•JSON
        parsed = JSON.parse(inputText);
      }

      // æ ¼å¼åŒ–JSON
      const formatted = JSON.stringify(parsed, null, 2);

      // åªæœ‰å½“æ ¼å¼åŒ–åçš„å†…å®¹ä¸å½“å‰ä¸åŒæ—¶æ‰æ›´æ–°
      if (formatted !== inputText) {
        // ä¿å­˜å½“å‰å…‰æ ‡ä½ç½®å’Œæ»šåŠ¨ä½ç½®
        const position = editor ? editor.getPosition() : null;
        const scrollTop = editor ? editor.getScrollTop() : null;

        // æ›´æ–°ç¼–è¾‘å™¨å†…å®¹
        setEditorContent(formatted);

        // æ¢å¤å…‰æ ‡ä½ç½®å’Œæ»šåŠ¨ä½ç½®
        if (position && editor) {
          editor.setPosition(position);
        }
        if (scrollTop !== null && editor) {
          editor.setScrollTop(scrollTop);
        }

        // å¦‚æœè½¬æ¢æˆåŠŸï¼Œæ˜¾ç¤ºæç¤º
        if (converted) {
          const typeNames = {
            'urlparams': 'URL å‚æ•°',
            'xml': 'XML',
            'yaml': 'YAML'
          };
          showToast(`å·²ä» ${typeNames[inputType]} è½¬æ¢ä¸º JSON`);
        }
      }

      // ä¿å­˜åˆ°å†å²è®°å½•
      saveToHistory(formatted);
    } catch (e) {
      // è§£æå¤±è´¥ï¼Œä¸åšå¤„ç†
      console.debug('Parsing error:', e);
    }
  }

  // JSONæ ‘å½¢æŸ¥çœ‹å™¨
  class JsonViewer {
    constructor(containerId, data) {
      this.container = document.getElementById(containerId);
      if (!this.container) return;

      this.data = data;
      this.render();
      this.bindEvents();
    }

    render() {
      this.container.innerHTML = this.renderValue(this.data, '', true);
    }

    renderValue(value, key = '', hasNext = true) {
      if (value === null) {
        return this.renderProperty(key, `<span class="json-value-null">null</span>`, hasNext);
      }

      if (typeof value === 'object') {
        if (Array.isArray(value)) {
          return this.renderObjectOrArray(key, value, 'array', hasNext);
        } else {
          return this.renderObjectOrArray(key, value, 'object', hasNext);
        }
      }

      if (typeof value === 'string') {
        return this.renderProperty(key, `<span class="json-value-string">"${this.escapeHtml(value)}"</span>`, hasNext);
      }

      if (typeof value === 'number') {
        return this.renderProperty(key, `<span class="json-value-number">${value}</span>`, hasNext);
      }

      if (typeof value === 'boolean') {
        return this.renderProperty(key, `<span class="json-value-boolean">${value}</span>`, hasNext);
      }

      return this.renderProperty(key, value, hasNext);
    }

    renderProperty(key, value, hasNext) {
      if (key === '') {
        if (typeof value === 'object') {
          if (Array.isArray(value)) {
            return this.renderObjectContent(value, 'array');
          } else {
            return this.renderObjectContent(value, 'object');
          }
        }
        return `<div class="json-root">${value}${hasNext ? ',' : ''}</div>`;
      }

      return `
        <div class="json-property">
          <span class="json-toggle">â–¼</span>
          <span class="json-key">"${key}"</span>
          <span class="json-separator">:</span>
          <span class="json-value">${value}</span>
          ${hasNext ? '<span>,</span>' : ''}
        </div>
      `;
    }

    renderObjectOrArray(key, value, type, hasNext) {
      const length = Array.isArray(value) ? value.length : Object.keys(value).length;
      const displayName = type === 'array' ? `[${length}]` : `{${length}}`;

      return `
        <div class="json-property collapsible">
          <span class="json-toggle">â–¼</span>
          ${key ? `<span class="json-key">"${key}"</span><span class="json-separator">:</span>` : ''}
          <span class="json-value json-value-${type}">${displayName}</span>
          ${hasNext ? '<span>,</span>' : ''}
          <div class="json-node">${this.renderObjectContent(value)}</div>
        </div>
      `;
    }

    renderObjectContent(obj) {
      if (Array.isArray(obj)) {
        return `
          <div class="json-bracket">[</div>
          <div class="json-node">
            ${obj.map((item, index) => {
              const hasNext = index < obj.length - 1;
              return this.renderValue(item, '', hasNext);
            }).join('')}
          </div>
          <div class="json-bracket">]</div>
        `;
      } else {
        const entries = Object.entries(obj);
        return `
          <div class="json-bracket">{</div>
          <div class="json-node">
            ${entries.map(([key, value], index) => {
              const hasNext = index < entries.length - 1;
              return this.renderValue(value, key, hasNext);
            }).join('')}
          </div>
          <div class="json-bracket">}</div>
        `;
      }
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    bindEvents() {
      this.container.addEventListener('click', (e) => {
        const toggle = e.target.closest('.json-toggle');
        if (toggle) {
          this.toggleNode(toggle);
        }
      });
    }

    toggleNode(toggle) {
      const property = toggle.parentElement;
      property.classList.toggle('collapsed');

      if (property.classList.contains('collapsed')) {
        toggle.textContent = 'â–¶';
      } else {
        toggle.textContent = 'â–¼';
      }
    }
  }

  // å°† JsonViewer æš´éœ²åˆ°å…¨å±€
  window.JsonViewer = JsonViewer;

  // å±•å¼€è¾“å‡ºåŒºåŸŸ
  function expandOutput(title = 'è¾“å‡ºç»“æœ') {
    const outputArea = document.getElementById('output-area');
    const outputTitle = document.getElementById('output-title');
    outputArea.classList.add('expanded');
    outputTitle.textContent = title;
  }

  // å…³é—­è¾“å‡ºåŒºåŸŸ
  function closeOutput() {
    const outputArea = document.getElementById('output-area');
    outputArea.classList.remove('expanded');
  }

  // æ˜¾ç¤ºJSONç»“æœ
  function showJsonResult(data, title = 'æ ¼å¼åŒ–ç»“æœ') {
    if (outputEditor) {
      const jsonStr = JSON.stringify(data, null, 2);
      outputEditor.setValue(jsonStr);
      expandOutput(title);
    } else {
      console.error('Output editor not initialized');
    }
  }

  function initializeJsonFormatter() {
    // åº”ç”¨æå–å‡½æ•°
    document.getElementById('apply-extract').addEventListener('click', () => {
      applyExtractFunction();
    });

    // æ¸…ç©ºæå–å‡½æ•°è¾“å…¥æ¡†
    document.getElementById('clear-extract-fn').addEventListener('click', () => {
      document.getElementById('extract-fn').value = '';
    });

    // æŒ‰é’®äº‹ä»¶ç»‘å®š
    document.getElementById('clear-btn').addEventListener('click', clearInputs);
    document.getElementById('collapse-all').addEventListener('click', collapseAll);
    document.getElementById('expand-all').addEventListener('click', expandAll);
    document.getElementById('remove-comments').addEventListener('click', removeComments);
    document.getElementById('compress-copy').addEventListener('click', () => compressAndCopy());
    document.getElementById('escape-copy').addEventListener('click', () => escapeAndCopy());
    document.getElementById('json-to-xml').addEventListener('click', () => jsonToXmlAndCopy());
    document.getElementById('json-to-ts').addEventListener('click', () => jsonToTsAndCopy());
    document.getElementById('json-to-csv').addEventListener('click', () => jsonToCsvAndCopy());
    document.getElementById('json-to-excel').addEventListener('click', () => jsonToExcelAndCopy());
    document.getElementById('json-to-yaml').addEventListener('click', () => jsonToYamlAndCopy());
    document.getElementById('json-to-html').addEventListener('click', () => jsonToHtmlAndCopy());
    document.getElementById('json-to-table').addEventListener('click', () => jsonToTable());
    document.getElementById('json-to-schema').addEventListener('click', () => jsonToSchema());
    document.getElementById('json-to-pdf').addEventListener('click', () => jsonToPdf());
    document.getElementById('json-to-dart').addEventListener('click', () => jsonToDartAndCopy());
    document.getElementById('json-to-c').addEventListener('click', () => jsonToCAndCopy());
    document.getElementById('json-to-go').addEventListener('click', () => jsonToGoAndCopy());
    document.getElementById('json-to-rust').addEventListener('click', () => jsonToRustAndCopy());
    document.getElementById('json-to-python').addEventListener('click', () => jsonToPythonAndCopy());
    document.getElementById('json-compare').addEventListener('click', () => toggleCompareMode());
    document.getElementById('close-output').addEventListener('click', closeOutput);
    document.getElementById('history-btn').addEventListener('click', showHistory);

    // å­—ä½“å¤§å°é€‰æ‹©å™¨
    const fontSizeSelect = document.getElementById('font-size-select');
    const savedFontSize = localStorage.getItem('editorFontSize') || '13';
    fontSizeSelect.value = savedFontSize;

    fontSizeSelect.addEventListener('change', (e) => {
      const fontSize = parseInt(e.target.value);
      if (editor) {
        editor.updateOptions({ fontSize: fontSize });
      }
      if (outputEditor) {
        outputEditor.updateOptions({ fontSize: fontSize });
      }
      localStorage.setItem('editorFontSize', fontSize);
    });
  }

  // é˜²æŠ–å‡½æ•°
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // æ ¼å¼åŒ–è¾“å…¥å‡½æ•°å·²ç§»é™¤ï¼Œä½¿ç”¨è‡ªåŠ¨æ ¼å¼åŒ–æ›¿ä»£

  // è§£æJSON
  function parseJson(str) {
    if (!str.trim()) return {};
    return JSON.parse(str);
  }

  // åº”ç”¨æå–å‡½æ•°
  async function applyExtractFunction() {
    const extractFnStr = document.getElementById('extract-fn').value.trim();

    if (!extractFnStr) {
      showToast(translations.enterExtractionFn || 'è¯·è¾“å…¥æå–å‡½æ•°');
      return;
    }

    try {
      const inputText = getEditorContent();
      if (!inputText.trim()) {
        showToast(translations.enterData || 'è¯·è¾“å…¥æ•°æ®');
        return;
      }

      const parsedData = parseJson(inputText);
      const fn = new Function('obj', `return (${extractFnStr})(obj);`);
      const result = fn(parsedData);

      // åªæœ‰åœ¨åº”ç”¨æå–å‡½æ•°åæ‰æ˜¾ç¤ºè¾“å‡ºæ¡†
      showJsonResult(result, 'æå–ç»“æœ');
    } catch (error) {
      showToast((translations.extractionError || 'æå–é”™è¯¯') + ': ' + error.message);
    }
  }

  // æ¸…ç©ºè¾“å…¥
  function clearInputs() {
    setEditorContent('');
    document.getElementById('extract-fn').value = '';
    if (outputEditor) {
      outputEditor.setValue('');
    }
    closeOutput();

    // é‡æ–°æ˜¾ç¤ºæç¤º
    const hint = document.getElementById('editor-hint');
    if (hint) {
      hint.classList.remove('hint-hidden');
    }
  }

  // æŠ˜å æ‰€æœ‰
  function collapseAll() {
    // æŠ˜å è¾“å…¥ç¼–è¾‘å™¨
    if (editor) {
      editor.getAction('editor.foldAll').run();
    }

    // æŠ˜å è¾“å‡ºç¼–è¾‘å™¨
    if (outputEditor) {
      outputEditor.getAction('editor.foldAll').run();
    }
  }

  // å±•å¼€æ‰€æœ‰
  function expandAll() {
    // å±•å¼€è¾“å…¥ç¼–è¾‘å™¨
    if (editor) {
      editor.getAction('editor.unfoldAll').run();
    }

    // å±•å¼€è¾“å‡ºç¼–è¾‘å™¨
    if (outputEditor) {
      outputEditor.getAction('editor.unfoldAll').run();
    }
  }

  // å»é™¤æ³¨é‡Š
  function removeComments() {
    let value = getEditorContent();
    value = value.replace(/\/\*[\s\S]*?\*\//g, '');
    value = value.replace(/\/\/.*/g, '');
    setEditorContent(value);
    // è§¦å‘è‡ªåŠ¨æ ¼å¼åŒ–
    autoFormatJson();
  }

  // å‹ç¼©å¹¶å¤åˆ¶
  async function compressAndCopy() {
    try {
      const inputContent = getEditorContent().trim();
      if (!inputContent) {
        showToast('è¯·è¾“å…¥è¦å¤„ç†çš„JSONæ•°æ®');
        return;
      }
      
      const parsedData = parseJson(inputContent);
      const compressed = JSON.stringify(parsedData);
      await navigator.clipboard.writeText(compressed);
      alert(translations.compressSuccess || 'å‹ç¼©æˆåŠŸå¹¶å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // è½¬ä¹‰å¹¶å¤åˆ¶
  async function escapeAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const compressed = JSON.stringify(parsedData);
      const escaped = compressed.replace(/[\\]/g, '\\\\').replace(/["]/g, '\\"');
      await navigator.clipboard.writeText(escaped);
      alert(translations.escapeSuccess || 'è½¬ä¹‰æˆåŠŸå¹¶å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // JSONè½¬XMLå¹¶å¤åˆ¶
  async function jsonToXmlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const xmlString = jsonToXml(parsedData, 'root');
      await navigator.clipboard.writeText(xmlString);
      alert(translations.xmlSuccess || 'XMLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // JSONè½¬TypeScriptå¹¶å¤åˆ¶
  async function jsonToTsAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const tsInterface = jsonToTsInterface(parsedData, 'DataType');
      await navigator.clipboard.writeText(tsInterface);
      alert(translations.tsSuccess || 'TypeScriptæ¥å£å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // JSONè½¬CSVå¹¶å¤åˆ¶
  async function jsonToCsvAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const csvString = jsonToCsv(parsedData);
      await navigator.clipboard.writeText(csvString);
      alert(translations.csvSuccess || 'CSVå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // JSONè½¬Excelå¹¶å¤åˆ¶ï¼ˆå®é™…ç”ŸæˆCSVæ ¼å¼ï¼Œå¯ç›´æ¥å¯¼å…¥Excelï¼‰
  async function jsonToExcelAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const csvString = jsonToCsv(parsedData);
      await navigator.clipboard.writeText(csvString);
      alert(translations.excelSuccess || 'Excelå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // ========== JSON to YAML ==========
  async function jsonToYamlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const yamlString = jsonToYaml(parsedData);
      await navigator.clipboard.writeText(yamlString);
      alert(translations.yamlSuccess || 'YAMLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  function jsonToYaml(obj, indent = 0) {
    const spaces = '  '.repeat(indent);
    if (obj === null || obj === undefined) return 'null';
    if (typeof obj !== 'object') return String(obj);
    if (Array.isArray(obj)) {
      if (obj.length === 0) return '[]';
      return obj.map(item => {
        if (typeof item === 'object' && item !== null) {
          return '-\n' + jsonToYaml(item, indent + 1).split('\n').map(line => spaces + line).join('\n').substring(2);
        } else {
          return '- ' + jsonToYaml(item, 0);
        }
      }).join('\n' + spaces);
    }
    const entries = Object.entries(obj);
    if (entries.length === 0) return '{}';
    return entries.map(([key, value]) => {
      if (value === null) return `${key}: null`;
      else if (typeof value === 'object' && value !== null) {
        return `${key}:\n${jsonToYaml(value, indent + 1).split('\n').map(line => spaces + line).join('\n')}`;
      } else if (typeof value === 'string') return `${key}: "${value}"`;
      else return `${key}: ${value}`;
    }).join('\n' + spaces);
  }

  // ========== JSON to Table ==========
  function expandOutput(title = 'è¾“å‡ºç»“æœ') {
    const outputArea = document.getElementById('output-area');
    const outputTitle = document.getElementById('output-title');
    if (outputArea && outputTitle) {
      outputArea.classList.add('expanded');
      outputTitle.textContent = title;
    }
  }

  async function jsonToTable() {
    try {
      const parsedData = parseJson(getEditorContent());
      const tableHtml = jsonToTableHtml(parsedData);
      if (outputEditor) {
        const outputContent = document.getElementById('output-content');
        if (outputContent) {
          const tempDiv = document.createElement('div');
          tempDiv.className = 'table-output';
          tempDiv.innerHTML = '<div style="padding: 20px; overflow: auto;">' + tableHtml + '</div>';
          const monacoContainer = outputContent.querySelector('.monaco-editor-container');
          if (monacoContainer) monacoContainer.style.setProperty('display', 'none');
          const existingTable = outputContent.querySelector('.table-output');
          if (existingTable) existingTable.remove();
          outputContent.appendChild(tempDiv);
          expandOutput('JSONè¡¨æ ¼');
        }
      }
      alert(translations.tableSuccess || 'è¡¨æ ¼ç”ŸæˆæˆåŠŸ');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  function jsonToTableHtml(obj) {
    if (!obj || typeof obj !== 'object') return '<p>è¾“å…¥ä¸æ˜¯æœ‰æ•ˆçš„JSONå¯¹è±¡</p>';
    if (Array.isArray(obj)) {
      if (obj.length === 0) return '<p>ç©ºæ•°ç»„</p>';
      const allKeys = [...new Set(obj.flatMap(item => Object.keys(item || {})))];
      if (allKeys.length === 0) return '<table class="json-table"><tbody><tr><td>åŒ…å« ' + obj.length + ' é¡¹çš„æ•°ç»„ï¼ˆæ— å±æ€§ï¼‰</td></tr></tbody></table>';
      let html = '<table class="json-table"><thead><tr>';
      allKeys.forEach(key => html += '<th>' + escapeHtml(key) + '</th>');
      html += '</tr></thead><tbody>';
      obj.forEach(item => {
        html += '<tr>';
        allKeys.forEach(key => html += '<td>' + formatValueForTable(item && item[key]) + '</td>');
        html += '</tr>';
      });
      html += '</tbody></table>';
      return html;
    }
    const entries = Object.entries(obj);
    let html = '<table class="json-table"><tbody>';
    entries.forEach(([key, value]) => {
      html += '<tr>';
      html += '<td class="key-column"><strong>' + escapeHtml(key) + '</strong></td>';
      html += '<td>' + formatValueForTable(value) + '</td>';
      html += '</tr>';
    });
    html += '</tbody></table>';
    return html;
  }

  function formatValueForTable(value) {
    if (value === null || value === undefined) return '<em>null</em>';
    if (typeof value === 'object') return '<code class="inline-code">' + escapeHtml(JSON.stringify(value)) + '</code>';
    if (typeof value === 'boolean') return '<span class="boolean-' + value + '">' + value + '</span>';
    if (typeof value === 'number') return '<span class="number">' + value + '</span>';
    return escapeHtml(String(value));
  }

  // ========== JSON Schema ==========
  async function jsonToSchema() {
    try {
      const parsedData = parseJson(getEditorContent());
      const schema = generateJsonSchema(parsedData, 'RootObject');
      if (outputEditor) {
        outputEditor.setValue(JSON.stringify(schema, null, 2));
        expandOutput('JSON Schema');
      }
      alert(translations.schemaSuccess || 'JSON Schemaç”ŸæˆæˆåŠŸ');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  function generateJsonSchema(obj, typeName) {
    if (obj === null || obj === undefined) return { type: 'null' };
    if (typeof obj === 'string') return { type: 'string' };
    if (typeof obj === 'number') return { type: 'number' };
    if (typeof obj === 'boolean') return { type: 'boolean' };
    if (Array.isArray(obj)) {
      if (obj.length > 0) return { type: 'array', items: generateJsonSchema(obj[0]) };
      return { type: 'array', items: {} };
    }
    const properties = {};
    const required = [];
    for (const [key, value] of Object.entries(obj)) {
      properties[key] = generateJsonSchema(value);
      required.push(key);
    }
    return { type: 'object', properties, required };
  }

  // ========== JSON to HTML ==========
  async function jsonToHtmlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const htmlString = '<!DOCTYPE html><html><head><title>JSON</title><style>body{font-family:monospace;padding:20px;}.json-key{color:#0066cc;}.json-string{color:#008000;}.json-number{color:#ff0000;}.json-boolean{color:#990000;}.json-null{color:#999;}</style></head><body><pre>' + jsonToHtmlInternal(parsedData) + '</pre></body></html>';
      await navigator.clipboard.writeText(htmlString);
      alert(translations.htmlSuccess || 'HTMLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  function jsonToHtmlInternal(obj, indent = 0) {
    const spaces = '  '.repeat(indent);
    if (obj === null || obj === undefined) return spaces + '<span class="json-null">null</span>\n';
    if (typeof obj !== 'object') {
      const formatted = typeof obj === 'string' ? '"' + obj + '"' : String(obj);
      const cls = typeof obj === 'string' ? 'json-string' : typeof obj === 'number' ? 'json-number' : typeof obj === 'boolean' ? 'json-boolean' : '';
      return spaces + '<span class="' + cls + '">' + escapeHtml(formatted) + '</span>\n';
    }
    if (Array.isArray(obj)) {
      if (obj.length === 0) return spaces + '[]\n';
      let html = spaces + '[\n';
      obj.forEach((item, index) => {
        html += jsonToHtmlInternal(item, indent + 1);
        if (index < obj.length - 1) html = html.trimEnd() + ',\n';
      });
      html += spaces + ']\n';
      return html;
    }
    const entries = Object.entries(obj);
    if (entries.length === 0) return spaces + '{}\n';
    let html = spaces + '{\n';
    entries.forEach(([key, value], index) => {
      html += spaces + '  <span class="json-key">"' + escapeHtml(key) + '"</span>: ';
      if (typeof value === 'object' && value !== null) {
        html += '\n' + jsonToHtmlInternal(value, indent + 2);
      } else {
        html += jsonToHtmlInternal(value, 0).trim();
      }
      if (index < entries.length - 1) html += ',';
      html += '\n';
    });
    html += spaces + '}\n';
    return html;
  }

  // ========== JSON to PDF ==========
  async function jsonToPdf() {
    try {
      const parsedData = parseJson(getEditorContent());
      const jsonStr = JSON.stringify(parsedData, null, 2);
      const htmlContent = '<!DOCTYPE html><html><head><title>JSONå¯¼å‡º</title><style>body{font-family:monospace;white-space:pre-wrap;padding:20px;}@media print{body{padding:0;}}</style></head><body>' + escapeHtml(jsonStr) + '</body></html>';
      const printWindow = window.open('', '_blank');
      printWindow.document.write(htmlContent);
      printWindow.document.close();
      printWindow.focus();
      setTimeout(() => printWindow.print(), 250);
      alert(translations.pdfSuccess || 'PDFå¯¼å‡ºå·²å¯åŠ¨');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  // ========== æ–¹æ¡ˆ3: ä»£ç ç”Ÿæˆå‡½æ•° ==========
  async function jsonToDartAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const code = generateClassCode(parsedData, 'JsonObject', 'dart');
      await navigator.clipboard.writeText(code);
      alert(translations.dartSuccess || 'Dartä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  async function jsonToCAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const code = generateStructCode(parsedData, 'JsonObject', 'c');
      await navigator.clipboard.writeText(code);
      alert(translations.cSuccess || 'Cä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  async function jsonToGoAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const code = generateStructCode(parsedData, 'JsonObject', 'go');
      await navigator.clipboard.writeText(code);
      alert(translations.goSuccess || 'Goä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  async function jsonToRustAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const code = generateStructCode(parsedData, 'JsonObject', 'rust');
      await navigator.clipboard.writeText(code);
      alert(translations.rustSuccess || 'Rustä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  async function jsonToPythonAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const code = generateClassCode(parsedData, 'JsonObject', 'python');
      await navigator.clipboard.writeText(code);
      alert(translations.pythonSuccess || 'Pythonä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  function generateClassCode(obj, className, lang) {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return '// æ— æ³•ä¸º' + typeof obj + 'ç”Ÿæˆ' + lang + 'ç±»';
    }
    let code = '';
    if (lang === 'dart') {
      code = 'class ' + className + ' {\n';
      for (const [key, value] of Object.entries(obj)) {
        const type = getDartType(value);
        code += '  ' + type + ' ' + camelCase(key) + ';\n';
      }
      code += '\n  ' + className + '({\n';
      for (const [key] of Object.entries(obj)) code += '    this.' + camelCase(key) + ',\n';
      code += '  });\n\n  factory ' + className + '.fromJson(Map<String, dynamic> json) {\n';
      code += '    return ' + className + '(\n';
      for (const [key] of Object.entries(obj)) code += '      ' + camelCase(key) + ': json[\'' + key + '\'],\n';
      code += '    );\n  }\n  Map<String, dynamic> toJson() {\n    return {';
      for (const [key] of Object.entries(obj)) code += '\n      \'' + key + '\': ' + camelCase(key) + ',';
      code += '\n    };\n  }\n}\n';
    } else if (lang === 'python') {
      code = 'from dataclasses import dataclass\nfrom typing import Optional, List, Any\n\n@dataclass\nclass ' + className + ':\n';
      for (const [key, value] of Object.entries(obj)) {
        const type = getPythonType(value);
        code += '  ' + snakeCase(key) + ': ' + type + '\n';
      }
    }
    return code;
  }

  function generateStructCode(obj, structName, lang) {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return '// æ— æ³•ä¸º' + typeof obj + 'ç”Ÿæˆ' + lang + 'ç»“æ„ä½“';
    }
    let code = '';
    if (lang === 'c') {
      code = 'typedef struct {\n';
      for (const [key, value] of Object.entries(obj)) {
        const type = getCType(value);
        code += '  ' + type + ' ' + camelCase(key) + ';\n';
      }
      code += '} ' + structName + ';\n';
    } else if (lang === 'go') {
      code = 'type ' + structName + ' struct {\n';
      for (const [key, value] of Object.entries(obj)) {
        const type = getGoType(value);
        code += '  ' + pascalCase(key) + ' ' + type + ' `json:"' + key + '"`\n';
      }
      code += '}\n';
    } else if (lang === 'rust') {
      code = '#[derive(Serialize, Deserialize)]\nstruct ' + structName + ' {\n';
      for (const [key, value] of Object.entries(obj)) {
        const type = getRustType(value);
        code += '  #[serde(rename = "' + key + '")]\n  ' + snakeCase(key) + ': ' + type + ',\n';
      }
      code += '}\n';
    }
    return code;
  }

  function getDartType(value) {
    if (value === null) return 'dynamic';
    if (typeof value === 'string') return 'String';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'double';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'List<dynamic>';
    return 'Map<String, dynamic>';
  }

  function getPythonType(value) {
    if (value === null) return 'Optional[Any]';
    if (typeof value === 'string') return 'str';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'List[Any]';
    return 'dict';
  }

  function getCType(value) {
    if (value === null) return 'void*';
    if (typeof value === 'string') return 'char*';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'double';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'void**';
    return 'void*';
  }

  function getGoType(value) {
    if (value === null) return 'interface{}';
    if (typeof value === 'string') return 'string';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float64';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return '[]interface{}';
    return 'map[string]interface{}';
  }

  function getRustType(value) {
    if (value === null) return 'Option<Value>';
    if (typeof value === 'string') return 'String';
    if (typeof value === 'number') return Number.isInteger(value) ? 'i64' : 'f64';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'Vec<Value>';
    return 'Value';
  }

  function pascalCase(str) {
    return str.replace(/(\w)(\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase()).replace(/[^a-zA-Z0-9]/g, '');
  }

  // å·¥å…·å‡½æ•°
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function camelCase(str) {
    return str.replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');
  }

  function snakeCase(str) {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '').replace(/[^a-zA-Z0-9]/g, '_');
  }

  function pascalCase(str) {
    return str.replace(/(\w)(\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase()).replace(/[^a-zA-Z0-9]/g, '');
  }

  // ========== æ‰€æœ‰æ–°è½¬æ¢å‡½æ•° ==========

  // JSON to YAML
  async function jsonToYamlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const yamlString = jsonToYaml(parsedData);
      await navigator.clipboard.writeText(yamlString);
      alert(translations.yamlSuccess || 'YAMLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (error) {
      alert((translations.parsingError || 'è§£æé”™è¯¯') + ': ' + error.message);
    }
  }

  function jsonToYaml(obj, indent = 0) {
    const spaces = '  '.repeat(indent);
    if (obj === null || obj === undefined) return 'null';
    if (typeof obj !== 'object') return String(obj);
    if (Array.isArray(obj)) {
      if (obj.length === 0) return '[]';
      return obj.map(item => {
        if (typeof item === 'object' && item !== null) {
          return '-\n' + jsonToYaml(item, indent + 1).split('\n').map(line => spaces + line).join('\n').substring(2);
        } else {
          return '- ' + jsonToYaml(item, 0);
        }
      }).join('\n' + spaces);
    }
    const entries = Object.entries(obj);
    if (entries.length === 0) return '{}';
    return entries.map(([key, value]) => {
      if (value === null) return `${key}: null`;
      else if (typeof value === 'object' && value !== null) {
        return `${key}:\n${jsonToYaml(value, indent + 1).split('\n').map(line => spaces + line).join('\n')}`;
      } else if (typeof value === 'string') return `${key}: "${value}"`;
      else return `${key}: ${value}`;
    }).join('\n' + spaces);
  }

  // JSONè½¬CSVè¾…åŠ©å‡½æ•°
  function jsonToCsv(obj) {
    // å¤„ç†ç©ºå€¼
    if (obj === null || obj === undefined) {
      throw new Error('è¾“å…¥æ•°æ®ä¸èƒ½ä¸ºç©º');
    }

    // ç¡®ä¿è¾“å…¥æ˜¯æ•°ç»„ï¼Œå¦‚æœæ˜¯å•ä¸ªå¯¹è±¡åˆ™è½¬æ¢ä¸ºæ•°ç»„
    const jsonArray = Array.isArray(obj) ? obj : [obj];

    // å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
    if (jsonArray.length === 0) {
      throw new Error('è¾“å…¥æ•°ç»„ä¸èƒ½ä¸ºç©º');
    }

    // è·å–æ‰€æœ‰å”¯ä¸€çš„é”®ä½œä¸ºCSVæ ‡é¢˜
    const headers = new Set();
    let hasValidData = false;
    jsonArray.forEach(item => {
      if (typeof item === 'object' && item !== null) {
        const keys = Object.keys(item);
        if (keys.length > 0) {
          hasValidData = true;
          keys.forEach(key => headers.add(key));
        }
      }
    });

    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼ŒæŠ›å‡ºé”™è¯¯
    if (!hasValidData) {
      throw new Error('æ²¡æœ‰å¯è½¬æ¢çš„æœ‰æ•ˆæ•°æ®');
    }

    // å°†Setè½¬æ¢ä¸ºæ•°ç»„
    const headerArray = Array.from(headers);

    // è¾…åŠ©å‡½æ•°ï¼šå°†ä»»æ„å€¼è½¬æ¢ä¸ºCSVå­—ç¬¦ä¸²
    function valueToCsvString(value) {
      // å¤„ç†nullå’Œundefined
      if (value === null || value === undefined) {
        return '';
      }

      // å¤„ç†å¯¹è±¡å’Œæ•°ç»„ï¼ˆè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²ï¼‰
      if (typeof value === 'object') {
        value = JSON.stringify(value);
      }

      // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
      let str = String(value);

      // è½¬ä¹‰å¼•å·ï¼ˆå°†"å˜æˆ""ï¼‰
      str = str.replace(/"/g, '""');

      // å¦‚æœåŒ…å«é€—å·ã€å¼•å·ã€æ¢è¡Œç¬¦ï¼Œç”¨å¼•å·åŒ…è£¹
      if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        str = `"${str}"`;
      }

      return str;
    }

    // ç”ŸæˆCSVå†…å®¹
    let csv = headerArray.join(',') + '\n';

    // éå†æ•°ç»„ç”ŸæˆCSVè¡Œ
    jsonArray.forEach(item => {
      const row = headerArray.map(header => {
        const value = item[header];
        return valueToCsvString(value);
      });
      csv += row.join(',') + '\n';
    });

    return csv;
  }

  // JSONè½¬XMLè¾…åŠ©å‡½æ•°
  function jsonToXml(obj, tagName) {
    if (obj === null || obj === undefined) {
      return `<${tagName}></${tagName}>`;
    }

    if (typeof obj !== 'object') {
      return `<${tagName}>${obj}</${tagName}>`;
    }

    if (Array.isArray(obj)) {
      return obj.map(item => jsonToXml(item, tagName)).join('');
    }

    let xml = `<${tagName}>`;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (typeof value === 'object') {
          xml += jsonToXml(value, key);
        } else {
          xml += `<${key}>${value}</${key}>`;
        }
      }
    }
    xml += `</${tagName}>`;

    return xml;
  }

  // JSONè½¬TypeScriptæ¥å£è¾…åŠ©å‡½æ•°
  function jsonToTsInterface(obj, interfaceName) {
    if (typeof obj !== 'object' || obj === null) {
      return `// æ— æ³•ä»éå¯¹è±¡ç±»å‹ç”Ÿæˆæ¥å£`;
    }

    // å¦‚æœæ˜¯æ•°ç»„ï¼Œä½¿ç”¨æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ç”Ÿæˆæ¥å£
    let targetObj = obj;
    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return `// æ— æ³•ä»ç©ºæ•°ç»„ç”Ÿæˆæ¥å£`;
      }
      // ä½¿ç”¨æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ç”Ÿæˆæ¥å£
      targetObj = obj[0];
      // å¦‚æœç¬¬ä¸€ä¸ªå…ƒç´ ä¸æ˜¯å¯¹è±¡ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯
      if (typeof targetObj !== 'object' || targetObj === null) {
        return `// æ— æ³•ä»éå¯¹è±¡ç±»å‹ç”Ÿæˆæ¥å£`;
      }
    }

    let ts = `interface ${interfaceName} {\n`;

    for (const key in targetObj) {
      if (targetObj.hasOwnProperty(key)) {
        const value = targetObj[key];
        let type;

        if (value === null) {
          type = 'any';
        } else if (Array.isArray(value)) {
          if (value.length > 0) {
            const elementType = typeof value[0];
            if (elementType === 'object' && value[0] !== null) {
              // å¦‚æœæ•°ç»„å…ƒç´ æ˜¯å¯¹è±¡ï¼Œç”ŸæˆåµŒå¥—æ¥å£
              const nestedInterfaceName = `${key.charAt(0).toUpperCase() + key.slice(1)}Item`;
              type = `${nestedInterfaceName}[]`;
              ts += jsonToTsInterface(value[0], nestedInterfaceName);
            } else {
              // å¦åˆ™ä½¿ç”¨åŸºæœ¬ç±»å‹
              type = `${getType(elementType)}[]`;
            }
          } else {
            type = 'any[]';
          }
        } else if (typeof value === 'object') {
          type = `${key.charAt(0).toUpperCase() + key.slice(1)}Type`;
          ts += jsonToTsInterface(value, type);
        } else {
          type = getType(typeof value);
        }

        ts += `  ${key}: ${type};\n`;
      }
    }

    ts += `}\n`;
    
    // å¦‚æœåŸå§‹è¾“å…¥æ˜¯æ•°ç»„ï¼Œç”Ÿæˆæ•°ç»„ç±»å‹å¯¼å‡º
    if (Array.isArray(obj)) {
      ts += `\nexport type ${interfaceName}Array = ${interfaceName}[];\n`;
    }
    
    return ts;
  }

  // è·å–ç±»å‹å­—ç¬¦ä¸²
  function getType(jsType) {
    switch(jsType) {
      case 'string': return 'string';
      case 'number': return 'number';
      case 'boolean': return 'boolean';
      case 'object': return 'object';
      default: return 'any';
    }
  }

  // æœ¬åœ°å­˜å‚¨ç›¸å…³å‡½æ•°
  const HISTORY_KEY = 'json-formatter-history';
  const MAX_HISTORY_ITEMS = 50;

  // ä¿å­˜å†å²è®°å½•
  function saveToHistory(data) {
    try {
      const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
      
      // ç§»é™¤é‡å¤é¡¹
      const filteredHistory = history.filter(item => item.data !== data);
      
      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
      filteredHistory.unshift({
        id: Date.now(),
        data: data,
        timestamp: new Date().toISOString()
      });
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      const limitedHistory = filteredHistory.slice(0, MAX_HISTORY_ITEMS);
      
      localStorage.setItem(HISTORY_KEY, JSON.stringify(limitedHistory));
    } catch (error) {
      console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', error);
    }
  }

  // è·å–å†å²è®°å½•
  function getHistory() {
    try {
      return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
    } catch (error) {
      console.error('è·å–å†å²è®°å½•å¤±è´¥:', error);
      return [];
    }
  }

  // æ¸…é™¤å†å²è®°å½•
  function clearHistory() {
    try {
      localStorage.removeItem(HISTORY_KEY);
    } catch (error) {
      console.error('æ¸…é™¤å†å²è®°å½•å¤±è´¥:', error);
    }
  }

  // æ˜¾ç¤ºå†å²è®°å½•
  function showHistory() {
    const history = getHistory();
    
    if (history.length === 0) {
      showToast('æš‚æ— å†å²è®°å½•');
      return;
    }
    
    // åˆ›å»ºé®ç½©å±‚
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
    `;
    
    // åˆ›å»ºå†å²è®°å½•å¼¹çª—
    const historyContainer = document.createElement('div');
    historyContainer.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      width: 90%;
      max-width: 1200px;
      max-height: 90%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    `;
    
    // åˆ›å»ºæ ‡é¢˜è¡Œ
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    `;
    
    // åˆ›å»ºæ ‡é¢˜
    const title = document.createElement('h3');
    title.textContent = 'å†å²è®°å½•';
    title.style.cssText = `
      margin: 0;
      font-size: 18px;
    `;
    header.appendChild(title);
    
    // åˆ›å»ºå…³é—­æŒ‰é’®
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background-color 0.2s;
    `;
    
    closeBtn.onmouseenter = () => {
      closeBtn.style.backgroundColor = '#f5f5f5';
    };
    
    closeBtn.onmouseleave = () => {
      closeBtn.style.backgroundColor = 'transparent';
    };
    
    closeBtn.onclick = () => {
      document.body.removeChild(overlay);
      document.body.removeChild(historyContainer);
    };
    
    header.appendChild(closeBtn);
    historyContainer.appendChild(header);
    
    // åˆ›å»ºæœç´¢æ¡†
    const searchContainer = document.createElement('div');
    searchContainer.style.cssText = `
      margin-bottom: 15px;
    `;
    
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.placeholder = 'æœç´¢å†å²è®°å½•...';
    searchInput.style.cssText = `
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    `;
    
    searchContainer.appendChild(searchInput);
    historyContainer.appendChild(searchContainer);
    
    // åˆ›å»ºæ¸…é™¤å†å²è®°å½•æŒ‰é’®
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'æ¸…é™¤æ‰€æœ‰å†å²è®°å½•';
    clearBtn.style.cssText = `
      margin-bottom: 15px;
      padding: 8px 16px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    `;
    
    clearBtn.onmouseenter = () => {
      clearBtn.style.backgroundColor = '#dc2626';
    };
    
    clearBtn.onmouseleave = () => {
      clearBtn.style.backgroundColor = '#ef4444';
    };
    
    clearBtn.onclick = () => {
      if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ')) {
        clearHistory();
        document.body.removeChild(overlay);
        document.body.removeChild(historyContainer);
        showToast('å†å²è®°å½•å·²æ¸…é™¤');
      }
    };
    
    historyContainer.appendChild(clearBtn);
    
    // åˆ›å»ºè¡¨æ ¼å®¹å™¨
    const tableContainer = document.createElement('div');
    tableContainer.style.cssText = `
      flex: 1;
      overflow: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    `;
    
    // åˆ›å»ºè¡¨æ ¼
    const table = document.createElement('table');
    table.style.cssText = `
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    `;
    
    // åˆ›å»ºè¡¨å¤´
    const thead = document.createElement('thead');
    thead.style.cssText = `
      background-color: #f9fafb;
      position: sticky;
      top: 0;
      z-index: 10;
    `;
    
    const headerRow = document.createElement('tr');
    const headers = ['åºå·', 'æ—¶é—´', 'JSONæ•°æ®', 'æ“ä½œ'];
    const headerWidths = ['60px', '150px', 'auto', '120px'];
    
    headers.forEach((headerText, index) => {
      const th = document.createElement('th');
      th.textContent = headerText;
      th.style.cssText = `
        padding: 10px 8px;
        text-align: left;
        border-bottom: 2px solid #ddd;
        font-weight: 600;
        width: ${headerWidths[index]};
      `;
      headerRow.appendChild(th);
    });
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // åˆ›å»ºè¡¨ä½“
    const tbody = document.createElement('tbody');
    
    // æ·»åŠ è®°å½•åˆ°è¡¨æ ¼çš„å‡½æ•°
    function addRecordsToTable(records) {
      tbody.innerHTML = '';
      
      records.forEach((item, index) => {
        const tr = document.createElement('tr');
        tr.style.cssText = `
          border-bottom: 1px solid #eee;
          transition: background-color 0.2s;
        `;
        
        tr.onmouseenter = () => {
          tr.style.backgroundColor = '#f5f5f5';
        };
        
        tr.onmouseleave = () => {
          tr.style.backgroundColor = 'transparent';
        };
        
        // åºå·åˆ—
        const indexTd = document.createElement('td');
        indexTd.textContent = index + 1;
        indexTd.style.cssText = `
          padding: 8px;
          text-align: center;
          font-weight: 500;
        `;
        tr.appendChild(indexTd);
        
        // æ—¶é—´åˆ—
        const timeTd = document.createElement('td');
        timeTd.textContent = new Date(item.timestamp).toLocaleString();
        timeTd.style.cssText = `
          padding: 8px;
          color: #666;
        `;
        tr.appendChild(timeTd);
        
        // JSONæ•°æ®åˆ—
        const dataTd = document.createElement('td');
        dataTd.style.cssText = `
          padding: 8px;
          max-width: 500px;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          font-size: 12px;
          cursor: pointer;
          color: #2563eb;
        `;
        
        const jsonPreview = item.data.substring(0, 150) + (item.data.length > 150 ? '...' : '');
        dataTd.textContent = jsonPreview;
        dataTd.title = 'ç‚¹å‡»å¤åˆ¶å®Œæ•´JSON';
        
        // ç‚¹å‡»JSONæ•°æ®å¤åˆ¶åˆ°å‰ªè´´æ¿
        dataTd.onclick = (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(item.data).then(() => {
            showToast('JSONå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
          }).catch(err => {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
          });
        };
        
        tr.appendChild(dataTd);
        
        // æ“ä½œåˆ—
        const actionTd = document.createElement('td');
        actionTd.style.cssText = `
          padding: 8px;
          display: flex;
          gap: 6px;
          justify-content: center;
        `;
        
        // å¤åˆ¶æŒ‰é’®
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'å¤åˆ¶';
        copyBtn.style.cssText = `
          padding: 4px 8px;
          background: #3b82f6;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          transition: background-color 0.2s;
        `;
        
        copyBtn.onmouseenter = () => {
          copyBtn.style.backgroundColor = '#2563eb';
        };
        
        copyBtn.onmouseleave = () => {
          copyBtn.style.backgroundColor = '#3b82f6';
        };
        
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(item.data).then(() => {
            showToast('JSONå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
          }).catch(err => {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
          });
        };
        
        actionTd.appendChild(copyBtn);
        
        // åˆ é™¤æŒ‰é’®
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.style.cssText = `
          padding: 4px 8px;
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          transition: background-color 0.2s;
        `;
        
        deleteBtn.onmouseenter = () => {
          deleteBtn.style.backgroundColor = '#dc2626';
        };
        
        deleteBtn.onmouseleave = () => {
          deleteBtn.style.backgroundColor = '#ef4444';
        };
        
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm(translations.deleteConfirm || 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ')) {
            const updatedHistory = history.filter(h => h.id !== item.id);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(updatedHistory));
            // æ›´æ–°è¡¨æ ¼
            const filteredHistory = searchInput.value
              ? updatedHistory.filter(h => h.data.includes(searchInput.value))
              : updatedHistory;
            addRecordsToTable(filteredHistory);
            showToast(translations.recordDeleted || 'è®°å½•å·²åˆ é™¤');
          }
        };
        
        actionTd.appendChild(deleteBtn);
        tr.appendChild(actionTd);
        
        // ç‚¹å‡»æ•´è¡Œæ¢å¤æ•°æ®
        tr.onclick = () => {
          setEditorContent(item.data);
          autoFormatJson();
          document.body.removeChild(overlay);
          document.body.removeChild(historyContainer);
        };
        
        tbody.appendChild(tr);
      });
    }
    
    // åˆå§‹åŠ è½½æ‰€æœ‰è®°å½•
    addRecordsToTable(history);
    
    table.appendChild(tbody);
    tableContainer.appendChild(table);
    historyContainer.appendChild(tableContainer);
    
    // æ·»åŠ æœç´¢åŠŸèƒ½
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      const filteredHistory = history.filter(item => 
        item.data.toLowerCase().includes(searchTerm)
      );
      addRecordsToTable(filteredHistory);
    });
    
    // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
    overlay.onclick = () => {
      document.body.removeChild(overlay);
      document.body.removeChild(historyContainer);
    };
    
    // æ·»åŠ åˆ°é¡µé¢
    document.body.appendChild(overlay);
    document.body.appendChild(historyContainer);
  }

  // åˆ‡æ¢æ¯”è¾ƒæ¨¡å¼
  function toggleCompareMode() {
    const compareSection = document.getElementById('compare-section');
    const editorsWrapper = document.getElementById('editors-wrapper');
    const firstSection = document.querySelector('.input-section');

    if (!isCompareMode) {
      // è¿›å…¥æ¯”è¾ƒæ¨¡å¼ - æ˜¾ç¤ºç¬¬äºŒä¸ªç¼–è¾‘å™¨
      isCompareMode = true;
      compareSection.classList.remove('hidden');
      editorsWrapper.classList.add('compare-mode');

      // æ›´æ–°ç¬¬ä¸€ä¸ªç¼–è¾‘å™¨æ ‡é¢˜
      const firstLabel = firstSection.querySelector('.section-label');
      if (firstLabel) {
        firstLabel.textContent = translations.leftJson || 'å·¦ä¾§JSON';
      }

      // ç«‹å³æ›´æ–°å·®å¼‚é«˜äº®
      highlightDifferences();
    } else {
      // é€€å‡ºæ¯”è¾ƒæ¨¡å¼
      isCompareMode = false;
      compareSection.classList.add('hidden');
      editorsWrapper.classList.remove('compare-mode');

      // æ¢å¤ç¼–è¾‘å™¨æ ‡é¢˜
      const firstLabel = firstSection.querySelector('.section-label');
      if (firstLabel) {
        firstLabel.textContent = 'Ø£Ø¯Ø§Ø© JSON Ø´Ø§Ù…Ù„Ø©';
      }

      // æ¸…é™¤é«˜äº®
      clearHighlightDecorations();

      // æ¸…ç©ºæ¯”è¾ƒç¼–è¾‘å™¨
      if (compareEditor) {
        compareEditor.setValue('');
      }
    }

    // æ›´æ–°å¸ƒå±€
    setTimeout(() => {
      if (editor) editor.layout();
      if (compareEditor) compareEditor.layout();
      if (outputEditor) outputEditor.layout();
    }, 100);
  }

  // åœ¨ä¸¤ä¸ªç¼–è¾‘å™¨ä¸­é«˜äº®æ˜¾ç¤ºå·®å¼‚
  function highlightDifferences() {
    if (!editor || !compareEditor) return;

    // æ¸…é™¤ä¹‹å‰çš„è£…é¥°
    clearHighlightDecorations();

    try {
      const leftText = editor.getValue();
      const rightText = compareEditor.getValue();

      if (!leftText.trim() || !rightText.trim()) return;

      // ç®€å•çš„è¡Œæ¯”è¾ƒæ–¹æ³•
      const leftLines = leftText.split('\n');
      const rightLines = rightText.split('\n');
      
      // åœ¨å·¦ä¾§ç¼–è¾‘å™¨ä¸­é«˜äº®å·®å¼‚
      const leftDecorationsData = [];
      const maxLines = Math.max(leftLines.length, rightLines.length);
      
      for (let i = 0; i < maxLines; i++) {
        const leftLine = leftLines[i] || '';
        const rightLine = rightLines[i] || '';
        
        // è·³è¿‡ç©ºè¡Œæ¯”è¾ƒ
        if (!leftLine.trim() && !rightLine.trim()) continue;
        
        // å·¦ä¾§æœ‰è¡Œï¼Œå³ä¾§æ²¡æœ‰ - åˆ é™¤
        if (leftLine.trim() && !rightLine.trim()) {
          leftDecorationsData.push({
            range: new monaco.Range(i + 1, 1, i + 1, 1000),
            options: {
              className: 'diff-removed',
              hoverMessage: { value: 'è¯¥è¡Œå·²åˆ é™¤' }
            }
          });
        }
        // è¡Œå†…å®¹ä¸åŒ - ä¿®æ”¹
        else if (leftLine.trim() !== rightLine.trim()) {
          leftDecorationsData.push({
            range: new monaco.Range(i + 1, 1, i + 1, 1000),
            options: {
              className: 'diff-changed',
              hoverMessage: { value: `ä¿®æ”¹: ${leftLine.trim()} â†’ ${rightLine.trim()}` }
            }
          });
        }
      }
      
      // åœ¨å³ä¾§ç¼–è¾‘å™¨ä¸­é«˜äº®å·®å¼‚
      const rightDecorationsData = [];
      for (let i = 0; i < maxLines; i++) {
        const leftLine = leftLines[i] || '';
        const rightLine = rightLines[i] || '';
        
        // è·³è¿‡ç©ºè¡Œæ¯”è¾ƒ
        if (!leftLine.trim() && !rightLine.trim()) continue;
        
        // å³ä¾§æœ‰è¡Œï¼Œå·¦ä¾§æ²¡æœ‰ - æ–°å¢
        if (!leftLine.trim() && rightLine.trim()) {
          rightDecorationsData.push({
            range: new monaco.Range(i + 1, 1, i + 1, 1000),
            options: {
              className: 'diff-added',
              hoverMessage: { value: 'è¯¥è¡Œå·²æ–°å¢' }
            }
          });
        }
        // è¡Œå†…å®¹ä¸åŒ - ä¿®æ”¹
        else if (leftLine.trim() !== rightLine.trim()) {
          rightDecorationsData.push({
            range: new monaco.Range(i + 1, 1, i + 1, 1000),
            options: {
              className: 'diff-changed',
              hoverMessage: { value: `ä¿®æ”¹: ${leftLine.trim()} â†’ ${rightLine.trim()}` }
            }
          });
        }
      }

      // åº”ç”¨è£…é¥°
      if (editor) {
        leftDecorations = editor.deltaDecorations([], leftDecorationsData);
      }
      if (compareEditor) {
        rightDecorations = compareEditor.deltaDecorations([], rightDecorationsData);
      }
    } catch (error) {
      // JSONè§£æå¤±è´¥ï¼Œä¸æ˜¾ç¤ºé«˜äº®
      console.debug('Highlight differences error:', error);
    }
  }

  // æŸ¥æ‰¾å·®å¼‚ï¼ˆè¿”å›å¸¦è¡Œå·ä¿¡æ¯çš„å·®å¼‚ï¼‰
  function findDifferences(obj1, obj2, path = '', depth = 0) {
    const differences = [];

    function compare(val1, val2, currentPath, currentLine = 0) {
      const type1 = typeof val1;
      const type2 = typeof val2;

      // ç±»å‹ä¸åŒ
      if (type1 !== type2) {
        differences.push({
          type: 'changed',
          path: currentPath,
          oldValue: val1,
          newValue: val2,
          message: `${currentPath}: ${JSON.stringify(val1)} â†’ ${JSON.stringify(val2)}`,
          line: currentLine
        });
        return;
      }

      // å¦‚æœæ˜¯å¯¹è±¡æˆ–æ•°ç»„ï¼Œé€’å½’æ¯”è¾ƒ
      if (type1 === 'object' && val1 !== null && val2 !== null) {
        const keys1 = Object.keys(val1);
        const keys2 = Object.keys(val2);
        const allKeys = new Set([...keys1, ...keys2]);

        allKeys.forEach((key, index) => {
          const newPath = currentPath ? `${currentPath}.${key}` : key;
          const lineOffset = Math.floor(index / 5); // ä¼°ç®—è¡Œå·

          if (!(key in val1)) {
            // æ–°å¢
            differences.push({
              type: 'added',
              path: newPath,
              value: val2[key],
              message: `${newPath}: + ${JSON.stringify(val2[key])}`,
              line: currentLine + lineOffset
            });
          } else if (!(key in val2)) {
            // åˆ é™¤
            differences.push({
              type: 'removed',
              path: newPath,
              value: val1[key],
              message: `${newPath}: - ${JSON.stringify(val1[key])}`,
              line: currentLine + lineOffset
            });
          } else {
            // é€’å½’æ¯”è¾ƒ
            compare(val1[key], val2[key], newPath, currentLine + lineOffset);
          }
        });
      } else if (val1 !== val2) {
        // å€¼ä¸åŒ
        differences.push({
          type: 'changed',
          path: currentPath,
          oldValue: val1,
          newValue: val2,
          message: `${currentPath}: ${JSON.stringify(val1)} â†’ ${JSON.stringify(val2)}`,
          line: currentLine
        });
      }
    }

    compare(obj1, obj2, path);

    return differences;
  }

  // æ¸…é™¤é«˜äº®è£…é¥°
  function clearHighlightDecorations() {
    if (editor && leftDecorations.length > 0) {
      editor.deltaDecorations(leftDecorations, []);
      leftDecorations = [];
    }
    if (compareEditor && rightDecorations.length > 0) {
      compareEditor.deltaDecorations(rightDecorations, []);
      rightDecorations = [];
    }
  }

  // æ˜¾ç¤ºToastæç¤º
  function showToast(message) {
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰Toast
    let toast = document.getElementById('toast-message');
    if (toast) {
      toast.remove();
    }
    
    toast = document.createElement('div');
    toast.id = 'toast-message';
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 1001;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      animation: slideIn 0.3s ease-out;
    `;
    
    // æ·»åŠ åŠ¨ç”»æ ·å¼
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(toast);
    
    // 3ç§’åç§»é™¤Toast
    setTimeout(() => {
      toast.style.animation = 'slideIn 0.3s ease-out reverse';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
        if (style.parentNode) {
          style.parentNode.removeChild(style);
        }
      }, 300);
    }, 3000);
  }
</script>
