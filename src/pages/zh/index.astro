---
import BaseLayout from '../../layouts/BaseLayout.astro';
import Sidebar from '../../components/Sidebar.astro';
import zhTranslations from '../../i18n/locales/zh.js';
import LanguageSwitcher from '../../components/LanguageSwitcher.astro';

// ZH é¦–é¡µï¼Œå›ºå®šä½¿ç”¨zhè¯­è¨€
const lang = 'zh-CN';
const t = zhTranslations;
---

<BaseLayout
  title="JSON å·¥å…· - æ ¼å¼åŒ–ã€è½¬æ¢ä¸º ISONï¼ˆèŠ‚çœ 70% Tokenï¼‰ã€CSV | åœ¨çº¿"
  lang={lang}
  description="åœ¨çº¿JSONå·¥å…·é›†ï¼šæ ¼å¼åŒ–ã€éªŒè¯ã€å¯¹æ¯”ã€è½¬æ¢JSONä¸ºISONã€TOONã€CSVã€Excelã€XMLã€YAMLã€‚ISONæ ¼å¼å¯èŠ‚çœé«˜è¾¾70%çš„tokenã€‚å¿«é€Ÿã€å®‰å…¨çš„æµè§ˆå™¨å·¥å…·ã€‚"
  keywords="JSONæ ¼å¼åŒ–, JSONæ ¡éªŒ, JSONè§£æ, JSONå¯¹æ¯”, JSONè½¬ISON, JSONè½¬TOON, tokenä¼˜åŒ–, èŠ‚çœtoken, JSONè½¬CSV, JSONè½¬Excel"
>
  <Sidebar slot="sidebar" t={t} />
  <div slot="header">
    <LanguageSwitcher currentLocale="zh" />
  </div>

  <!-- Schema.org Structured Data for SEO & GEO -->
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "JSON æ ¼å¼åŒ–ä¸è§£æå·¥å…·",
    "description": "å…è´¹åœ¨çº¿JSONæ ¼å¼åŒ–ã€éªŒè¯å’Œè½¬æ¢å·¥å…·ã€‚æ”¯æŒJSONã€URLå‚æ•°ã€XMLã€YAMLè½¬æ¢ï¼Œæä¾›å­—æ®µæå–å’ŒTypeScriptç”ŸæˆåŠŸèƒ½ã€‚",
    "url": "https://tojsons.com",
    "applicationCategory": "DeveloperApplication",
    "operatingSystem": "Any",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "JSON æ ¼å¼åŒ–å’ŒéªŒè¯",
      "ISON æ ¼å¼è½¬æ¢ï¼ˆèŠ‚çœ 70% Tokenï¼‰",
      "TOON æ ¼å¼è½¬æ¢",
      "URL å‚æ•°è§£æ",
      "XML è½¬ JSON è½¬æ¢",
      "YAML è½¬ JSON è½¬æ¢",
      "JavaScript å­—æ®µæå–",
      "TypeScript æ¥å£ç”Ÿæˆ",
      "JSON è½¬ CSV è½¬æ¢",
      "JSON è½¬ Excel è½¬æ¢",
      "JSON è½¬ XML è½¬æ¢",
      "JSON å‹ç¼©",
      "JSON è½¬ä¹‰",
      "æ³¨é‡Šç§»é™¤"
    ],
    "browserRequirements": "Requires JavaScript. Compatible with all modern browsers.",
    "softwareVersion": "1.0.0",
    "author": {
      "@type": "Organization",
      "name": "JSON Viewer Team"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "1250"
    }
  })} />

  <div class="json-formatter-container"
       data-enter-extraction-fn={t.enterExtractionFn}
       data-enter-data={t.enterData}
       data-extraction-error={t.extractionError}
       data-parsing-error={t.parsingError}
       data-compress-success={t.compressSuccess}
       data-escape-success={t.escapeSuccess}
       data-xml-success={t.xmlSuccess}
       data-ts-success={t.tsSuccess}
       data-csv-success={t.csvSuccess}
       data-excel-success={t.excelSuccess}
       data-ison-success={t.isonSuccess}
       data-toon-success={t.toonSuccess}>

    <div class="editor-workspace">
      <!-- å·¦ä¾§è¾“å…¥åŒºåŸŸ -->
      <div class="input-area">
        <!-- ç¼–è¾‘å™¨å®¹å™¨ï¼ˆç”¨äºå·¦å³å¸ƒå±€ï¼‰ -->
        <div class="editors-wrapper" id="editors-wrapper">
          <!-- ä¸¤ä¸ªç‹¬ç«‹ç¼–è¾‘å™¨ -->
          <div class="input-section">
            <div class="section-header-row">
              <h1 class="section-label">JSON å·¥å…· - æ ¼å¼åŒ–ã€è½¬æ¢ä¸º ISONï¼ˆèŠ‚çœ 70% Tokenï¼‰ã€CSV ç­‰</h1>
              <div class="editor-hint-inline" id="editor-hint">
                <span class="hint-icon">âœ¨</span>
                <span class="hint-text">{t.smartInput}</span>
              </div>
            </div>
            <div class="input-editor-wrapper">
              <div id="monaco-editor-container" class="monaco-editor-container"></div>
            </div>
          </div>

          <!-- æ¯”è¾ƒæ¨¡å¼ï¼šç¬¬äºŒä¸ªç¼–è¾‘å™¨ -->
          <div class="input-section compare-editor hidden" id="compare-section">
            <h2 class="section-label">{t.rightJson}</h2>
            <div class="input-editor-wrapper">
              <div id="monaco-compare-container" class="monaco-editor-container"></div>
            </div>
          </div>
        </div>

        <!-- JSON æ ¡éªŒé”™è¯¯æç¤º -->
        <div id="json-validation-error" class="validation-error hidden"></div>

        <div class="extraction-section">
          <div class="extraction-controls">
            <label for="extract-fn">ğŸ“Š {t.extractionLabel}</label>
            <input
              type="text"
              id="extract-fn"
              placeholder={t.extractionPlaceholder}
            />
            <button id="apply-extract">{t.apply}</button>
            <button id="clear-extract-fn">{t.clear}</button>
          </div>
        </div>

        <div class="output-controls">
          <!-- åŸºç¡€æ“ä½œ -->
          <button id="collapse-all">{t.collapseAll}</button>
          <button id="expand-all">{t.expandAll}</button>
          <button id="remove-comments">{t.removeComments}</button>
          <button id="compress-copy">{t.compressCopy}</button>
          <button id="escape-copy">{t.escapeCopy}</button>

          <span class="button-separator">|</span>

          <!-- æ•°æ®æ ¼å¼è½¬æ¢ -->
          <button id="json-to-xml">{t.jsonToXml}</button>
          <button id="json-to-yaml">{t.jsonToYaml}</button>
          <button id="json-to-csv">{t.jsonToCsv}</button>
          <button id="json-to-excel">{t.jsonToExcel}</button>
          <button id="json-to-html">{t.jsonToHtml}</button>
          <button id="json-to-pdf">{t.jsonToPdf}</button>

          <span class="button-separator">|</span>

          <!-- ä»£ç ç”Ÿæˆ -->
          <button id="json-to-ts">{t.jsonToTs}</button>
          <button id="json-to-dart">{t.jsonToDart}</button>
          <button id="json-to-c">{t.jsonToC}</button>
          <button id="json-to-go">{t.jsonToGo}</button>
          <button id="json-to-rust">{t.jsonToRust}</button>
          <button id="json-to-python">{t.jsonToPython}</button>
          <button id="json-to-schema">{t.jsonToSchema}</button>

          <span class="button-separator">|</span>

          <!-- å¯è§†åŒ–ä¸åˆ†æ -->
          <button id="json-to-table">{t.jsonToTable}</button>
          <button id="json-compare">{t.jsonCompare}</button>

          <span class="button-separator">|</span>

          <!-- å…¶ä»– -->
          <button id="clear-btn">{t.clear}</button>
          <button id="history-btn">{t.history}</button>
          <select id="font-size-select" title="Font Size">
            <option value="11">11px</option>
            <option value="12">12px</option>
            <option value="13" selected>13px</option>
            <option value="14">14px</option>
            <option value="15">15px</option>
            <option value="16">16px</option>
          </select>
        </div>
      </div>

      <!-- å³ä¾§è¾“å‡ºåŒºåŸŸ -->
      <div class="output-area" id="output-area">
        <div class="output-header">
          <span class="output-title" id="output-title">è¾“å‡ºç»“æœ</span>
          <button class="close-output-btn" id="close-output" title="å…³é—­">Ã—</button>
        </div>
        <div class="output-content" id="output-content">
          <div class="output-editor-wrapper">
            <div id="output-monaco-container" class="monaco-editor-container"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- HowTo Tutorial Section -->
  <div class="tutorial-section">
    <div class="section-header">
      <h2>{t.tutorialTitle}</h2>
      <p>{t.tutorialSubtitle}</p>
    </div>

    <div class="tutorial-container">
      <div class="tutorial-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <h3>{t.tutorialStep1Title}</h3>
          <p>{t.tutorialStep1Desc}</p>
          <div class="step-example">
            <code set:text={t.tutorialStep1Example}></code>
          </div>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <h3>{t.tutorialStep2Title}</h3>
          <p>{t.tutorialStep2Desc}</p>
          <div class="tip">
            <strong>ğŸ’¡ {t.tutorialStep2Tip.split(':')[0]}:</strong> {t.tutorialStep2Tip.split(':')[1]}
          </div>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <h3>{t.tutorialStep3Title}</h3>
          <p set:text={t.tutorialStep3Desc}></p>
          <div class="step-example">
            <code set:text={t.tutorialStep3Example}></code>
          </div>
          <p class="example-desc" set:text={t.tutorialStep3ExampleDesc}></p>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <h3>{t.tutorialStep4Title}</h3>
          <p>{t.tutorialStep4Desc}</p>
          <div class="step-example">
            <pre><code set:text={t.tutorialStep4Example}></code></pre>
          </div>
          <p class="example-desc" set:text={t.tutorialStep4ExampleDesc}></p>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <h3>{t.tutorialStep5Title}</h3>
          <p>{t.tutorialStep5Desc}</p>
          <ul class="action-list">
            <li><strong>{t.tutorialStep5Action1.split(':')[0]}:</strong> {t.tutorialStep5Action1.split(':')[1]}</li>
            <li><strong>{t.tutorialStep5Action2.split(':')[0]}:</strong> {t.tutorialStep5Action2.split(':')[1]}</li>
            <li><strong>{t.tutorialStep5Action3.split(':')[0]}:</strong> {t.tutorialStep5Action3.split(':')[1]}</li>
            <li><strong>{t.tutorialStep5Action4.split(':')[0]}:</strong> {t.tutorialStep5Action4.split(':')[1]}</li>
            <li><strong>{t.tutorialStep5Action5.split(':')[0]}:</strong> {t.tutorialStep5Action5.split(':')[1]}</li>
          </ul>
        </div>
      </div>

      <div class="tutorial-step">
        <div class="step-number">6</div>
        <div class="step-content">
          <h3>{t.tutorialStep6Title}</h3>
          <p>{t.tutorialStep6Desc}</p>
          <div class="privacy-note">
            <strong>ğŸ”’ {t.tutorialStep6Privacy.split(':')[0]}:</strong> {t.tutorialStep6Privacy.split(':')[1]}
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Features Section -->
    <div class="features-section">
      <div class="section-header">
        <h2>{t.featuresTitle}</h2>
        <p>{t.featuresSubtitle}</p>
      </div>
      <div class="features-grid">
        <div class="feature-item">
          <div class="feature-number">01</div>
          <div class="feature-content">
            <div class="feature-icon">âœ¨</div>
            <h3>{t.feature1Title}</h3>
            <p>{t.feature1Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">02</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ”„</div>
            <h3>{t.feature2Title}</h3>
            <p>{t.feature2Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">03</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ¯</div>
            <h3>{t.feature3Title}</h3>
            <p>{t.feature3Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">04</div>
          <div class="feature-content">
            <div class="feature-icon">âš¡</div>
            <h3>{t.feature4Title}</h3>
            <p>{t.feature4Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">05</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ’»</div>
            <h3>{t.feature5Title}</h3>
            <p>{t.feature5Desc}</p>
          </div>
        </div>
        <div class="feature-item">
          <div class="feature-number">06</div>
          <div class="feature-content">
            <div class="feature-icon">ğŸ”’</div>
            <h3>{t.feature6Title}</h3>
            <p>{t.feature6Desc}</p>
          </div>
        </div>
      </div>
    </div>

    <!-- ISON & TOON åŠŸèƒ½äº®ç‚¹ -->
    <div class="ison-feature-section">
      <div class="section-header">
        <h2>ğŸš€ æ–°åŠŸèƒ½ï¼šä½¿ç”¨ ISON & TOON èŠ‚çœ 70% Token</h2>
        <p>ä¸“ä¸º LLM åº”ç”¨å’Œé«˜æ•ˆæ•°æ®å­˜å‚¨ä¼˜åŒ–çš„æ ¼å¼</p>
      </div>
      <div class="ison-grid">
        <div class="ison-card">
          <div class="ison-icon">ğŸ“Š</div>
          <h3>JSON è½¬ ISON</h3>
          <p>ä½¿ç”¨ LLM ä¼˜åŒ–çš„è¡¨æ ¼æ ¼å¼ï¼ŒèŠ‚çœé«˜è¾¾ 70% çš„ tokenã€‚éå¸¸é€‚åˆ AI åº”ç”¨å’Œ RAG ç³»ç»Ÿã€‚</p>
          <ul class="ison-features">
            <li>âœ“ ç±»å‹å®‰å…¨æ³¨è§£</li>
            <li>âœ“ å¹³å‡èŠ‚çœ 61% token</li>
            <li>âœ“ åŸºäºè¡¨æ ¼çš„ç»“æ„</li>
            <li>âœ“ åŒå‘è½¬æ¢</li>
          </ul>
          <a href="/zh/json-to-ison" class="ison-link">äº†è§£æ›´å¤š â†’</a>
        </div>
        <div class="ison-card">
          <div class="ison-icon">âš™ï¸</div>
          <h3>JSON è½¬ TOON</h3>
          <p>ç”¨äºé…ç½®æ–‡ä»¶å’Œç»“æ„åŒ–æ•°æ®çš„ç®€å•é”®å€¼å¯¹æ ¼å¼ã€‚æ¯” JSON é«˜æ•ˆ 52%ã€‚</p>
          <ul class="ison-features">
            <li>âœ“ é«˜åº¦å¯è¯»</li>
            <li>âœ“ é…ç½®æ–‡ä»¶ä¼˜åŒ–</li>
            <li>âœ“ ç®€å•è¯­æ³•</li>
            <li>âœ“ æ— æŸè½¬æ¢</li>
          </ul>
          <a href="/zh/json-to-toon" class="ison-link">äº†è§£æ›´å¤š â†’</a>
        </div>
      </div>
    </div>

    <!-- ISON è¯¦ç»†ä»‹ç» -->
    <div class="ison-detailed-section">
      <div class="section-header">
        <span class="section-tag">ğŸš€ æ–°åŠŸèƒ½</span>
        <h2 class="section-title">ISON æ ¼å¼ï¼šèŠ‚çœ 70% Token çš„ LLM ä¼˜åŒ–æ ¼å¼</h2>
        <p class="section-subtitle">ISONï¼ˆInterchange Simple Object Notationï¼‰æ˜¯ä¸“ä¸º LLM åº”ç”¨è®¾è®¡çš„é«˜æ•ˆæ•°æ®æ ¼å¼ï¼Œé€šè¿‡è¡¨æ ¼ç»“æ„å’Œç±»å‹æ³¨è§£å®ç°æ˜¾è‘—çš„ token èŠ‚çœ</p>
      </div>

      <div class="ison-content-grid">
        <div class="content-block">
          <h3 class="content-title">ä»€ä¹ˆæ˜¯ ISONï¼Ÿ</h3>
          <p class="content-description">ISON æ˜¯ä¸€ç§è¡¨æ ¼æ ¼å¼ï¼Œä½¿ç”¨ TSVï¼ˆåˆ¶è¡¨ç¬¦åˆ†éš”å€¼ï¼‰ç»“æ„ï¼Œå¹¶ä¸ºæ¯åˆ—æ·»åŠ ç±»å‹æ³¨è§£ã€‚è¿™ç§è®¾è®¡ä¸“é—¨é’ˆå¯¹ LLMï¼ˆå¤§è¯­è¨€æ¨¡å‹ï¼‰ä¼˜åŒ–ï¼Œå¯åœ¨ä¿æŒæ•°æ®å®Œæ•´æ€§çš„åŒæ—¶å¤§å¹…å‡å°‘ token æ¶ˆè€—ã€‚</p>

          <div class="code-example">users.tsv
id[int]	name[str]	age[int]	email[str]
1	å¼ ä¸‰	25	zhang@example.com
2	æå››	30	li@example.com
3	ç‹äº”	28	wang@example.com</div>

          <p class="content-description">ç›¸æ¯”ä¹‹ä¸‹ï¼Œç›¸åŒæ•°æ®çš„ JSON æ ¼å¼éœ€è¦æ›´å¤šçš„å­—ç¬¦å’Œ tokenã€‚</p>
        </div>

        <div class="content-block">
          <h3 class="content-title">Token èŠ‚çœå¯¹æ¯”</h3>
          <p class="content-description">åœ¨å®é™…æµ‹è¯•ä¸­ï¼ŒISON æ ¼å¼ç›¸æ¯” JSON æ ¼å¼å¹³å‡å¯èŠ‚çœ <strong>61%</strong> çš„ tokenï¼Œåœ¨å¤§å‹æ•°æ®é›†ä¸Šæœ€é«˜å¯è¾¾ <strong>70%</strong>ï¼š</p>

          <table class="token-comparison-table">
            <thead>
              <tr>
                <th>æ•°æ®é›†</th>
                <th>JSON Tokens</th>
                <th>ISON Tokens</th>
                <th>èŠ‚çœæ¯”ä¾‹</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ç”¨æˆ·æ•°æ®ï¼ˆ10æ¡ï¼‰</td>
                <td>458</td>
                <td>175</td>
                <td class="token-savings">61.8%</td>
              </tr>
              <tr>
                <td>äº§å“ç›®å½•ï¼ˆ50æ¡ï¼‰</td>
                <td>2,340</td>
                <td>876</td>
                <td class="token-savings">62.6%</td>
              </tr>
              <tr>
                <td>è®¢å•è®°å½•ï¼ˆ100æ¡ï¼‰</td>
                <td>5,120</td>
                <td>1,536</td>
                <td class="token-savings">70.0%</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="content-block">
          <h3 class="content-title">ISON æ ¼å¼ç»“æ„</h3>
          <p class="content-description">ISON ä½¿ç”¨ç®€æ´çš„è¯­æ³•æ¥è¡¨ç¤ºæ•°æ®ç±»å‹å’Œç»“æ„ï¼š</p>

          <div class="format-structure">
            <strong>ç±»å‹æ³¨è§£ï¼š</strong><br>
            â€¢ [int] - æ•´æ•°<br>
            â€¢ [str] - å­—ç¬¦ä¸²<br>
            â€¢ [float] - æµ®ç‚¹æ•°<br>
            â€¢ [bool] - å¸ƒå°”å€¼<br>
            â€¢ [array] - æ•°ç»„/åˆ—è¡¨<br>
            â€¢ ~ - null å€¼
          </div>

          <div class="code-example"># æ•°ç»„æ ¼å¼ï¼ˆè¡¨æ ¼ï¼‰
table.name[col1type]	col2[type2]	col3[type3]
value1	value2	value3

# å¯¹è±¡æ ¼å¼
object.name	key1[type1]	value1
object.name	key2[type2]	value2</div>
        </div>

        <div class="content-block">
          <h3 class="content-title">ä½¿ç”¨åœºæ™¯</h3>
          <ul class="use-case-list">
            <li><strong>RAG ç³»ç»Ÿï¼š</strong>å°†çŸ¥è¯†åº“æ•°æ®è½¬æ¢ä¸º ISON æ ¼å¼ï¼Œå¤§å¹…é™ä½æ£€ç´¢æ—¶çš„ token æ¶ˆè€—</li>
            <li><strong>AI Agentï¼š</strong>Agent ä¸Šä¸‹æ–‡æ•°æ®ä½¿ç”¨ ISON æ ¼å¼ï¼Œå¯åœ¨æœ‰é™çš„ token çª—å£å†…å¤„ç†æ›´å¤šæ•°æ®</li>
            <li><strong>API å“åº”ä¼˜åŒ–ï¼š</strong>LLM åº”ç”¨çš„ API å“åº”ä½¿ç”¨ ISON æ ¼å¼ï¼Œå‡å°‘ä¼ è¾“å’Œå¤„ç†æˆæœ¬</li>
            <li><strong>æ•°æ®å­˜å‚¨ï¼š</strong>é•¿æœŸå­˜å‚¨ç»“æ„åŒ–æ•°æ®ï¼Œæ¯” JSON æ›´èŠ‚çœç©ºé—´</li>
            <li><strong>æ—¥å¿—å¤„ç†ï¼š</strong>ç»“æ„åŒ–æ—¥å¿—æ•°æ®è½¬æ¢ä¸º ISONï¼Œä¾¿äº LLM åˆ†æå’Œå¤„ç†</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- TOON è¯¦ç»†ä»‹ç» -->
    <div class="toon-detailed-section">
      <div class="section-header">
        <span class="section-tag">âš™ï¸ é…ç½®ä¼˜åŒ–</span>
        <h2 class="section-title">TOON æ ¼å¼ï¼šç®€æ´é«˜æ•ˆçš„é”®å€¼å¯¹æ ¼å¼</h2>
        <p class="section-subtitle">TOON æä¾›äº†ç±»ä¼¼ INI çš„é…ç½®æ ¼å¼ï¼Œä½¿ç”¨é”®å€¼å¯¹å’Œç¼©è¿›è¡¨ç¤ºå±‚çº§å…³ç³»ï¼Œæ¯” JSON èŠ‚çœ 50% çš„ç©ºé—´</p>
      </div>

      <div class="toon-content-grid">
        <div class="content-block">
          <h3 class="content-title">ä»€ä¹ˆæ˜¯ TOONï¼Ÿ</h3>
          <p class="content-description">TOON æ˜¯ä¸€ç§ç®€æ´çš„é”®å€¼å¯¹æ ¼å¼ï¼Œä¸“ä¸ºé…ç½®æ–‡ä»¶å’Œç»“æ„åŒ–æ•°æ®è®¾è®¡ã€‚å®ƒä½¿ç”¨ç¼©è¿›æ¥è¡¨ç¤ºå±‚çº§å…³ç³»ï¼Œè¯­æ³•ç›´è§‚æ˜“è¯»ï¼ŒåŒæ—¶ä¿æŒé«˜æ•ˆçš„å­˜å‚¨æ•ˆç‡ã€‚</p>

          <div class="code-example"># TOON æ ¼å¼ç¤ºä¾‹
database
	host=localhost
	port=3306
	username=admin
	password=secret123
pool
	maxConnections=100
	minConnections=10</div>

          <p class="content-description">ä¸ JSON ç›¸æ¯”ï¼ŒTOON æ›´åŠ ç®€æ´ï¼Œå¯è¯»æ€§æ›´å¼ºï¼Œç‰¹åˆ«é€‚åˆé…ç½®æ–‡ä»¶åœºæ™¯ã€‚</p>
        </div>

        <div class="content-block">
          <h3 class="content-title">TOON è¯­æ³•ç‰¹ç‚¹</h3>
          <p class="content-description">TOON çš„è¯­æ³•è®¾è®¡ç®€æ´æ˜äº†ï¼š</p>

          <div class="format-structure">
            <strong>åŸºæœ¬è§„åˆ™ï¼š</strong><br>
            â€¢ ä½¿ç”¨ key=value æ ¼å¼å®šä¹‰é”®å€¼å¯¹<br>
            â€¢ ä½¿ç”¨ç¼©è¿›ï¼ˆä¸¤ä¸ªç©ºæ ¼ï¼‰è¡¨ç¤ºå±‚çº§å…³ç³»<br>
            â€¢ ä½¿ç”¨ # æ·»åŠ æ³¨é‡Š<br>
            â€¢ æ•°ç»„ä½¿ç”¨ [item1, item2] æ ¼å¼<br>
            â€¢ å­—ç¬¦ä¸²å€¼è‡ªåŠ¨æ£€æµ‹ï¼Œæ— éœ€å¼•å·ï¼ˆé™¤éåŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼‰
          </div>

          <div class="code-example"># åµŒå¥—å¯¹è±¡ç¤ºä¾‹
server
	domain=example.com
	ssl=true
	certificates
		key=/path/to/key.pem
		cert=/path/to/cert.pem</div>
        </div>

        <div class="content-block">
          <h3 class="content-title">ä½¿ç”¨åœºæ™¯</h3>
          <ul class="use-case-list">
            <li><strong>åº”ç”¨é…ç½®ï¼š</strong>æœåŠ¡å™¨é…ç½®ã€æ•°æ®åº“è¿æ¥ã€API å¯†é’¥ç­‰</li>
            <li><strong>ç¯å¢ƒå˜é‡ï¼š</strong>éƒ¨ç½²é…ç½®ã€ç¯å¢ƒç‰¹å®šè®¾ç½®</li>
            <li><strong>ç”¨æˆ·åå¥½ï¼š</strong>åº”ç”¨è®¾ç½®ã€ç”¨æˆ·é…ç½®æ–‡ä»¶</li>
            <li><strong>ç³»ç»Ÿå‚æ•°ï¼š</strong>ç³»ç»Ÿçº§é…ç½®ã€å¯åŠ¨å‚æ•°</li>
            <li><strong>CI/CD é…ç½®ï¼š</strong>æ„å»ºè„šæœ¬ã€éƒ¨ç½²æµç¨‹é…ç½®</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- æ ¼å¼å¯¹æ¯” -->
    <div class="format-comparison-section">
      <div class="section-header">
        <h2 class="section-title">é€‰æ‹©é€‚åˆæ‚¨çš„æ ¼å¼</h2>
        <p class="section-subtitle">æ ¹æ®ä½¿ç”¨åœºæ™¯é€‰æ‹©æœ€é€‚åˆçš„æ•°æ®æ ¼å¼ï¼Œæœ€å¤§åŒ–æ•ˆç‡</p>
      </div>

      <div class="comparison-grid">
        <div class="comparison-card ison">
          <span class="comparison-badge">æ¨è LLM</span>
          <h3>ISON æ ¼å¼</h3>
          <div class="token-saving">èŠ‚çœ 70%</div>
          <p>æœ€é€‚åˆ AI åº”ç”¨å’Œ RAG ç³»ç»Ÿã€‚è¡¨æ ¼ç»“æ„é…åˆç±»å‹æ³¨è§£ï¼Œå¤§å¹…å‡å°‘ token æ¶ˆè€—ã€‚</p>
        </div>

        <div class="comparison-card toon">
          <span class="comparison-badge">é…ç½®ä¼˜åŒ–</span>
          <h3>TOON æ ¼å¼</h3>
          <div class="token-saving">èŠ‚çœ 50%</div>
          <p>æœ€é€‚åˆé…ç½®æ–‡ä»¶å’Œç»“æ„åŒ–æ•°æ®ã€‚é”®å€¼å¯¹æ ¼å¼ç›´è§‚æ˜“è¯»ï¼Œç»´æŠ¤æ–¹ä¾¿ã€‚</p>
        </div>

        <div class="comparison-card json">
          <span class="comparison-badge">é€šç”¨æ ‡å‡†</span>
          <h3>JSON æ ¼å¼</h3>
          <div class="token-saving">åŸºå‡†</div>
          <p>Web å¼€å‘çš„æ ‡å‡†æ ¼å¼ï¼Œé€šç”¨æ€§å¼ºï¼Œæ‰€æœ‰å¹³å°éƒ½æ”¯æŒã€‚é€‚åˆä¸€èˆ¬æ•°æ®äº¤æ¢ã€‚</p>
        </div>
      </div>
    </div>

    <!-- Supported Formats Section -->
    <div class="supported-formats-section">
      <div class="section-header">
        <h2>{t.supportedFormatsTitle}</h2>
        <p>{t.supportedFormatsSubtitle}</p>
      </div>
      <div class="formats-grid">
        <div class="format-category">
          <h3>{t.formatCat1Title}</h3>
          <ul>
            <li>{t.formatCat1Item1}</li>
            <li>{t.formatCat1Item2}</li>
            <li>{t.formatCat1Item3}</li>
            <li>{t.formatCat1Item4}</li>
            <li>{t.formatCat1Item5}</li>
            <li>{t.formatCat1Item6}</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>{t.formatCat2Title}</h3>
          <ul>
            <li>{t.formatCat2Item1}</li>
            <li>{t.formatCat2Item2}</li>
            <li>{t.formatCat2Item3}</li>
            <li>{t.formatCat2Item4}</li>
            <li>{t.formatCat2Item5}</li>
            <li>{t.formatCat2Item6}</li>
            <li>{t.formatCat2Item7}</li>
            <li>{t.formatCat2Item8}</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>{t.formatCat3Title}</h3>
          <ul>
            <li>{t.formatCat3Item1}</li>
            <li>{t.formatCat3Item2}</li>
            <li>{t.formatCat3Item3}</li>
            <li>{t.formatCat3Item4}</li>
            <li>{t.formatCat3Item5}</li>
            <li>{t.formatCat3Item6}</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>{t.formatCat4Title}</h3>
          <ul>
            <li>{t.formatCat4Item1}</li>
            <li>{t.formatCat4Item2}</li>
            <li>{t.formatCat4Item3}</li>
            <li>{t.formatCat4Item4}</li>
            <li>{t.formatCat4Item5}</li>
            <li>{t.formatCat4Item6}</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>{t.formatCat5Title}</h3>
          <ul>
            <li>{t.formatCat5Item1}</li>
            <li>{t.formatCat5Item2}</li>
            <li>{t.formatCat5Item3}</li>
            <li>{t.formatCat5Item4}</li>
            <li>{t.formatCat5Item5}</li>
            <li>{t.formatCat5Item6}</li>
          </ul>
        </div>
        <div class="format-category">
          <h3>{t.formatCat6Title}</h3>
          <ul>
            <li>{t.formatCat6Item1}</li>
            <li>{t.formatCat6Item2}</li>
            <li>{t.formatCat6Item3}</li>
            <li>{t.formatCat6Item4}</li>
            <li>{t.formatCat6Item5}</li>
            <li>{t.formatCat6Item6}</li>
          </ul>
        </div>
      </div>
      <div class="formats-note">
        <p set:html={t.formatsNote} />
      </div>
    </div>

    <!-- FAQ Section -->
    <div class="faq-section">
      <div class="section-header">
        <h2>{t.faqTitle}</h2>
        <p>{t.faqSubtitle}</p>
      </div>
      <div class="faq-grid">
        <div class="faq-item">
          <h3>{t.faq1Question}</h3>
          <p>{t.faq1Answer}</p>
        </div>
        <div class="faq-item">
          <h3>{t.faq2Question}</h3>
          <p>{t.faq2Answer}</p>
        </div>
        <div class="faq-item">
          <h3>{t.faq3Question}</h3>
          <p>{t.faq3Answer}</p>
        </div>
        <div class="faq-item">
          <h3>{t.faq4Question}</h3>
          <p>{t.faq4Answer}</p>
        </div>
        <div class="faq-item">
          <h3>{t.faq5Question}</h3>
          <p>{t.faq5Answer}</p>
        </div>
        <div class="faq-item">
          <h3>{t.faq6Question}</h3>
          <p>{t.faq6Answer}</p>
        </div>

        <div class="faq-item">
          <h3>ISON å’Œ TOON æ˜¯ä»€ä¹ˆæ ¼å¼ï¼Ÿ</h3>
          <p>ISONï¼ˆInterchange Simple Object Notationï¼‰æ˜¯é¢å‘ LLM ä¼˜åŒ–çš„ç´§å‡‘ç»“æ„åŒ–æ ¼å¼ï¼Œé‡ç‚¹æ˜¯å‡å°‘ token æ¶ˆè€—ï¼›TOON æ˜¯æ›´åé…ç½®æ–‡ä»¶åœºæ™¯çš„ key=value ç»“æ„åŒ–æ ¼å¼ã€‚ä¸¤è€…éƒ½èƒ½ä¸ JSON äº’ç›¸è½¬æ¢ã€‚</p>
        </div>
        <div class="faq-item">
          <h3>å¦‚ä½•ä½¿ç”¨ ISON / TOON è½¬æ¢åŠŸèƒ½ï¼Ÿ</h3>
          <p>å°† JSON ç²˜è´´åˆ°è¾“å…¥åŒºåï¼Œç‚¹å‡» â€œJSON to ISONâ€ æˆ– â€œJSON to TOONâ€ æŒ‰é’®å³å¯ç”Ÿæˆç»“æœï¼Œå¹¶å¯ä¸€é”®å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚</p>
        </div>
        <div class="faq-item">
          <h3>ISON çœŸçš„èƒ½èŠ‚çœ 70% çš„ token å—ï¼Ÿ</h3>
          <p>åœ¨é”®åé‡å¤è¾ƒå¤šã€ç»“æ„è¾ƒæ·±çš„æ•°æ®ä¸­ï¼ŒISON é€šå¸¸èƒ½æ˜¾è‘—é™ä½ tokenã€‚å®é™…èŠ‚çœæ¯”ä¾‹å–å†³äºæ•°æ®ç»“æ„ï¼Œå¸¸è§èŒƒå›´åœ¨ 40%~70%ã€‚</p>
        </div>
        <div class="faq-item">
          <h3>è½¬æ¢åçš„æ•°æ®å¯ä»¥å†è½¬å› JSON å—ï¼Ÿ</h3>
          <p>å¯ä»¥ã€‚è¯¥å·¥å…·è®¾è®¡ç›®æ ‡ä¹‹ä¸€å°±æ˜¯ä¿æŒç»“æ„å¯é€†ï¼Œä¾¿äºåœ¨å‹ç¼©è¡¨ç¤ºå’Œæ ‡å‡† JSON ä¹‹é—´åˆ‡æ¢ã€‚</p>
        </div>
        <div class="faq-item">
          <h3>ä»€ä¹ˆæ—¶å€™æ›´é€‚åˆä½¿ç”¨ ISONï¼Ÿ</h3>
          <p>å½“ä½ è¦æŠŠå¤§é‡ç»“æ„åŒ–æ•°æ®å–‚ç»™ LLMï¼ˆå¦‚ RAGã€Agent ä¸Šä¸‹æ–‡ã€æ—¥å¿—åˆ†æï¼‰æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨ ISONï¼Œèƒ½æœ‰æ•ˆé™ä½ä¸Šä¸‹æ–‡å¼€é”€ã€‚</p>
        </div>
        <div class="faq-item">
          <h3>ä»€ä¹ˆæ—¶å€™æ›´é€‚åˆä½¿ç”¨ TOONï¼Ÿ</h3>
          <p>å½“ä½ æ›´å…³æ³¨å¯è¯»æ€§å’Œé…ç½®ç»´æŠ¤æ•ˆç‡æ—¶ï¼ˆå¦‚åº”ç”¨é…ç½®ã€éƒ¨ç½²å‚æ•°ã€ç¯å¢ƒå˜é‡ç®¡ç†ï¼‰ï¼ŒTOON å¾€å¾€æ¯” JSON æ›´ç›´è§‚ã€‚</p>
        </div>
      </div>
    </div>
  <!-- FAQPage Schema for GEO -->
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": t.faq1Question,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": t.faq1Answer
        }
      },
      {
        "@type": "Question",
        "name": t.faq2Question,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": t.faq2Answer
        }
      },
      {
        "@type": "Question",
        "name": t.faq3Question,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": t.faq3Answer
        }
      },
      {
        "@type": "Question",
        "name": t.faq4Question,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": t.faq4Answer
        }
      },
      {
        "@type": "Question",
        "name": t.faq5Question,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": t.faq5Answer
        }
      },
      {
        "@type": "Question",
        "name": t.faq6Question,
        "acceptedAnswer": {
          "@type": "Answer",
          "text": t.faq6Answer
        }
      }
    ]
  })} />

  <!-- HowTo Schema for GEO -->
  <script type="application/ld+json" set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "HowTo",
    "name": "How to Format and Validate JSON",
    "description": "Learn how to format, validate, and convert JSON data using our free online JSON viewer tool.",
    "step": [
      {
        "@type": "HowToStep",
        "name": "Paste Your JSON Data",
        "text": "Paste your JSON, URL parameters, XML, or YAML data into the input editor.",
        "image": "https://tojsons.com/step1.png"
      },
      {
        "@type": "HowToStep",
        "name": "Automatic Format Detection",
        "text": "The tool automatically detects your input format and converts it to JSON."
      },
      {
        "@type": "HowToStep",
        "name": "View Formatted JSON",
        "text": "See your beautifully formatted JSON with syntax highlighting and line numbers."
      },
      {
        "@type": "HowToStep",
        "name": "Validate JSON",
        "text": "Any JSON errors are highlighted with specific line numbers and error messages."
      },
      {
        "@type": "HowToStep",
        "name": "Extract or Convert",
        "text": "Use field extraction, convert to XML/YAML/TypeScript, or compress/copy the result."
      }
    ],
    "tool": [
      {
        "@type": "HowToTool",
        "name": "JSON Viewer Online"
      }
    ]
  })} />
</BaseLayout>

<style>
  :root {
    --diff-red-opacity: 239, 68, 68;
    --diff-green-opacity: 34, 197, 94;
    --diff-yellow-opacity: 234, 179, 8;
  }

  .json-formatter-container {
    max-width: 1800px;
    margin: 0 auto;
    padding: 8px;
    height: calc(100vh - var(--sidebar-height, 40px));
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
  }

  /* ä¸»å·¥ä½œåŒº - å·¦å³å¸ƒå±€ */
  .editor-workspace {
    display: flex;
    gap: 0;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  /* å·¦ä¾§è¾“å…¥åŒºåŸŸ */
  .input-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
    min-width: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    margin: 0 auto;
    max-width: 75%;
  }

  /* å½“è¾“å‡ºåŒºåŸŸå±•å¼€æ—¶ï¼Œè°ƒæ•´å¸ƒå±€ */
  .output-area.expanded {
    flex: 1;
    width: 50%;
    opacity: 1;
    border-left: 1px solid #e5e7eb;
    padding-left: 0;
  }

  /* å½“è¾“å‡ºåŒºåŸŸå±•å¼€æ—¶ï¼Œè¾“å…¥åŒºåŸŸä¹Ÿè°ƒæ•´ä¸º50% */
  .editor-workspace:has(.output-area.expanded) .input-area {
    flex: 1;
    max-width: 50%;
    margin: 0;
  }

  .input-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .section-label {
    font-size: 0.875rem;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    flex-shrink: 0;
  }

  /* H1æ ‡ç­¾æ ·å¼é‡ç½®ï¼Œä¿æŒå¸ƒå±€ä¸€è‡´ */
  h1.section-label {
    margin: 0;
    padding: 4px 0 6px 0;
    font-size: 1rem;
    font-weight: 700;
    color: #0f172a;
    flex-shrink: 0;
    display: block;
  }

  h2.section-label {
    margin: 0;
    padding: 0;
    font-size: 0.875rem;
    font-weight: 600;
    margin-top: 10px;
  }

  /* Section Header Row - æ ‡é¢˜å’Œæç¤ºåœ¨åŒä¸€è¡Œ */
  .section-header-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  /* Editor Hint Inline - å†…è”æç¤º */
  .editor-hint-inline {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(37, 99, 235, 0.08) 100%);
    border: 1px solid rgba(59, 130, 246, 0.2);
    border-radius: 6px;
    padding: 4px 10px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    flex-shrink: 0;
  }

  .editor-hint-inline:hover {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.12) 0%, rgba(37, 99, 235, 0.12) 100%);
    border-color: rgba(59, 130, 246, 0.3);
    box-shadow: 0 1px 4px rgba(59, 130, 246, 0.1);
  }

  .editor-hint-inline.hint-hidden {
    opacity: 0;
    transform: translateX(4px);
    pointer-events: none;
  }

  .editor-hint-inline .hint-icon {
    font-size: 14px;
    flex-shrink: 0;
    animation: sparkle 2s ease-in-out infinite;
  }

  @keyframes sparkle {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }

  .editor-hint-inline .hint-text {
    font-size: 0.75rem;
    font-weight: 600;
    color: #3b82f6;
    white-space: nowrap;
  }

  /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
  @media (max-width: 768px) {
    .section-header-row {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }

    .editor-hint-inline {
      padding: 3px 8px;
    }

    .editor-hint-inline .hint-icon {
      font-size: 12px;
    }

    .editor-hint-inline .hint-text {
      font-size: 0.7rem;
    }
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹çš„æ ‡é¢˜ä¼˜åŒ– */
  @media (max-width: 768px) {
    .editor-hint {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      padding: 8px 10px;
    }

    .hint-icon {
      font-size: 16px;
    }

    .hint-title {
      font-size: 0.8rem;
    }

    .hint-description {
      font-size: 0.7rem;
    }

    .hint-features {
      gap: 4px;
    }

    .hint-badge {
      font-size: 0.65rem;
      padding: 2px 6px;
    }

    .hint-security {
      font-size: 0.65rem;
      padding: 3px 8px;
      align-self: flex-start;
    }
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹çš„æ ‡é¢˜ä¼˜åŒ– */
  .editors-wrapper.compare-mode h1.section-label,
  .editors-wrapper.compare-mode h2.section-label {
    margin-top: 0;
    margin-bottom: 6px;
    text-align: center;
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹æ·»åŠ è¾¹æ¡†åŒºåˆ†ä¸¤ä¸ªç¼–è¾‘å™¨ */
  .editors-wrapper.compare-mode .input-section:first-child .input-editor-wrapper {
    border: 2px solid #3b82f6;
  }

  .editors-wrapper.compare-mode .compare-editor .input-editor-wrapper {
    border: 2px solid #10b981;
  }

  /* æ¯”è¾ƒæ¨¡å¼æ ·å¼ */
  .compare-editor {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .compare-editor.hidden {
    display: none;
  }

  /* ç¼–è¾‘å™¨åŒ…è£…å®¹å™¨ */
  .editors-wrapper {
    display: flex;
    flex: 1;
    gap: 0;
    min-height: 0;
  }

  /* æ¯”è¾ƒæ¨¡å¼ä¸‹çš„å¸ƒå±€è°ƒæ•´ */
  .editors-wrapper.compare-mode {
    gap: 10px;
  }

  .editors-wrapper.compare-mode .input-section {
    flex: 1;
    min-height: 0;
    min-width: 0;
  }

  .editors-wrapper.compare-mode .compare-editor {
    flex: 1;
    min-height: 0;
    min-width: 0;
  }

  /* ç§»åŠ¨ç«¯æ¯”è¾ƒæ¨¡å¼ä¿æŒä¸Šä¸‹ç»“æ„ */
  @media (max-width: 768px) {
    .editors-wrapper.compare-mode {
      flex-direction: column;
    }
  }

  /* Diffç»“æœæ ·å¼ */
  .diff-result {
    padding: 16px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 13px;
    line-height: 1.6;
    overflow: auto;
  }

  .diff-added {
    background-color: #d4edda;
    color: #155724;
    padding: 4px 8px;
    margin: 2px 0;
    border-left: 3px solid #28a745;
  }

  .diff-removed {
    background-color: #f8d7da;
    color: #721c24;
    padding: 4px 8px;
    margin: 2px 0;
    border-left: 3px solid #dc3545;
    text-decoration: line-through;
  }

  .diff-changed {
    background-color: #fff3cd;
    color: #856404;
    padding: 4px 8px;
    margin: 2px 0;
    border-left: 3px solid #ffc107;
  }

  .diff-unchanged {
    color: #6c757d;
    padding: 4px 8px;
    margin: 2px 0;
  }

  /* Monaco Editorå·®å¼‚é«˜äº®è£…é¥° - å¢å¼ºè§†è§‰æ•ˆæœ */
  .monaco-editor .diff-removed {
    background-color: rgba(239, 68, 68, 0.25) !important;
    border-left: 4px solid #ef4444 !important;
    position: relative !important;
  }

  .monaco-editor .diff-removed::before {
    content: '' !important;
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    width: 3px !important;
    background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%) !important;
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.4) !important;
  }

  .monaco-editor .diff-added {
    background-color: rgba(34, 197, 94, 0.25) !important;
    border-left: 4px solid #22c55e !important;
    position: relative !important;
  }

  .monaco-editor .diff-added::before {
    content: '' !important;
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    width: 3px !important;
    background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%) !important;
    box-shadow: 0 0 8px rgba(34, 197, 94, 0.4) !important;
  }

  .monaco-editor .diff-changed {
    background-color: rgba(234, 179, 8, 0.25) !important;
    border-left: 4px solid #eab308 !important;
    position: relative !important;
  }

  .monaco-editor .diff-changed::before {
    content: '' !important;
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    width: 3px !important;
    background: linear-gradient(180deg, #eab308 0%, #ca8a04 100%) !important;
    box-shadow: 0 0 8px rgba(234, 179, 8, 0.4) !important;
  }

  /* å·®å¼‚é«˜äº®è£…é¥°ç±» - ç”¨äºMonaco Editorçš„deltaDecorations */
  .diff-removed-decoration {
    background-color: rgba(239, 68, 68, 0.25) !important;
    border-left: 4px solid #ef4444 !important;
  }

  .diff-added-decoration {
    background-color: rgba(34, 197, 94, 0.25) !important;
    border-left: 4px solid #22c55e !important;
  }

  .diff-changed-decoration {
    background-color: rgba(234, 179, 8, 0.25) !important;
    border-left: 4px solid #eab308 !important;
  }

  /* å¢å¼ºå·®å¼‚é«˜äº®çš„å¯è§æ€§ */
  .monaco-editor .diff-removed-decoration,
  .monaco-editor .diff-added-decoration,
  .monaco-editor .diff-changed-decoration {
    position: relative !important;
    transition: all 0.2s ease !important;
  }

  .monaco-editor .diff-removed-decoration:hover,
  .monaco-editor .diff-added-decoration:hover,
  .monaco-editor .diff-changed-decoration:hover {
    filter: brightness(0.9) !important;
  }

  /* ç§»åŠ¨ç«¯å·®å¼‚é«˜äº®å¢å¼º */
  @media (max-width: 768px) {
    .monaco-editor .diff-removed-decoration {
      background-color: rgba(var(--diff-red-opacity), 0.35) !important;
      border-left: 4px solid #ef4444 !important;
      border-right: 2px solid rgba(239, 68, 68, 0.3) !important;
    }

    .monaco-editor .diff-added-decoration {
      background-color: rgba(var(--diff-green-opacity), 0.35) !important;
      border-left: 4px solid #22c55e !important;
      border-right: 2px solid rgba(34, 197, 94, 0.3) !important;
    }

    .monaco-editor .diff-changed-decoration {
      background-color: rgba(var(--diff-yellow-opacity), 0.35) !important;
      border-left: 4px solid #eab308 !important;
      border-right: 2px solid rgba(234, 179, 8, 0.3) !important;
    }

    /* ç§»åŠ¨ç«¯å·®å¼‚é«˜äº®åŠ¨ç”» */
    .monaco-editor .diff-removed-decoration,
    .monaco-editor .diff-added-decoration,
    .monaco-editor .diff-changed-decoration {
      animation: diffPulse 2s ease-in-out;
    }

    @keyframes diffPulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }
  }

  .input-editor-wrapper {
    display: flex;
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    overflow: hidden;
    flex: 1;
    min-height: 0;
    position: relative;
  }

  .monaco-editor-container {
    flex: 1;
    width: 100%;
    height: 100%;
    min-height: 400px;
    position: relative;
  }

  /* ç¾åŒ–Monaco EditoræŠ˜å æŒ‰é’® */
  .monaco-editor .codicon-add-selection,
  .monaco-editor .codicon-chevron-right,
  .monaco-editor .folding-icon::before,
  .monaco-editor .codicon-folding-expanded,
  .monaco-editor .codicon-folding-collapsed {
    content: '' !important;
  }

  /* è‡ªå®šä¹‰æŠ˜å æŒ‰é’®æ ·å¼ */
  .monaco-editor .folding-icon {
    width: 16px !important;
    height: 16px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
  }

  /* å±•å¼€çŠ¶æ€çš„æŠ˜å æŒ‰é’® */
  .monaco-editor .folding-icon.collapsed::after,
  .monaco-editor .codicon-folding-collapsed::after {
    content: 'â–¶' !important;
    font-size: 10px !important;
    color: #6b7280 !important;
    display: inline-block !important;
    margin-left: 1px !important;
  }

  /* æŠ˜å çŠ¶æ€çš„æŠ˜å æŒ‰é’® */
  .monaco-editor .folding-icon:not(.collapsed)::after,
  .monaco-editor .codicon-folding-expanded::after {
    content: 'â–¼' !important;
    font-size: 9px !important;
    color: #6b7280 !important;
    display: inline-block !important;
  }

  /* æŠ˜å æŒ‰é’®hoveræ•ˆæœ */
  .monaco-editor .folding-icon:hover::after {
    color: #3b82f6 !important;
  }

  /* JSON æ ¡éªŒé”™è¯¯æç¤º */
  .validation-error {
    padding: 12px 16px;
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    border: 1px solid #fecaca;
    border-radius: 6px;
    margin-bottom: 10px;
    font-size: 0.875rem;
    color: #991b1b;
    border-left: 4px solid #ef4444;
    display: none;
    animation: slideDown 0.3s ease-out;
  }

  .validation-error {
    padding: 12px 16px;
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    border: 1px solid #fecaca;
    border-radius: 6px;
    margin-bottom: 10px;
    font-size: 0.875rem;
    color: #991b1b;
    border-left: 4px solid #ef4444;
    display: none;
    animation: slideDown 0.3s ease-out;
  }

  .validation-error.show {
    display: block;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* æå–åŒºåŸŸ */
  .extraction-section {
    padding: 10px 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
    border-radius: 6px;
    border: 1px solid #e9ecef;
  }

  .extraction-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .extraction-controls label {
    font-weight: 600;
    color: var(--text-color);
    white-space: nowrap;
    font-size: 0.85rem;
  }

  .extraction-controls input {
    flex: 1;
    min-width: 200px;
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    font-size: 13px;
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: all 0.2s;
  }

  .extraction-controls input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .extraction-controls button {
    padding: 6px 14px;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s;
  }

  #apply-extract {
    font-size: 13px;
  }

  .extraction-controls button:hover {
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    transform: translateY(-1px);
  }

  #clear-extract-fn {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    font-size: 13px;
  }

  #clear-extract-fn:hover {
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
  }

/* æŒ‰é’®ç»„ */
  .output-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .output-controls button {
    padding: 6px 10px;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 11px;
    font-weight: 500;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    flex: 0 0 auto;
    min-width: fit-content;
  }

  .output-controls select {
    padding: 6px 10px;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 11px;
    font-weight: 500;
    transition: all 0.2s;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  .output-controls select option {
    background: white;
    color: #1f2937;
    padding: 6px 10px;
  }

  .output-controls select:hover {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    transform: translateY(-1px);
  }

  .output-controls button:hover {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    box-shadow: 0 2px 6px rgba(37, 99, 235, 0.3);
    transform: translateY(-1px);
  }

  /* ç§»åŠ¨ç«¯æŒ‰é’®äº¤äº’ä¼˜åŒ– */
  .output-controls button:active {
    transform: translateY(0) scale(0.98);
    transition: all 0.1s;
  }

  .output-controls select:active {
    transform: translateY(0) scale(0.98);
    transition: all 0.1s;
  }

  #clear-btn {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
  }

  #clear-btn:hover {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important;
    box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3);
  }

  /* æŒ‰é’®åˆ†éš”ç¬¦æ ·å¼ */
  .button-separator {
    display: flex;
    align-items: center;
    justify-content: center;
    color: #9ca3af;
    font-weight: bold;
    padding: 0 4px;
    user-select: none;
  }

  @media (max-width: 768px) {
    .button-separator {
      display: none; /* ç§»åŠ¨ç«¯éšè—åˆ†éš”ç¬¦ */
    }
  }

  /* JSONè¡¨æ ¼æ ·å¼ */
  .json-table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
    font-size: 14px;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  .json-table thead {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
  }

  .json-table th {
    padding: 12px 16px;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid #e5e7eb;
  }

  .json-table td {
    padding: 10px 16px;
    border-bottom: 1px solid #f3f4f6;
  }

  .json-table tbody tr:hover {
    background-color: #f9fafb;
  }

  .json-table tbody tr:last-child td {
    border-bottom: none;
  }

  .json-table .key-column {
    background-color: #f9fafb;
    font-weight: 600;
    width: 30%;
    border-right: 1px solid #e5e7eb;
  }

  .json-table .inline-code {
    background-color: #f3f4f6;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 12px;
    color: #1f2937;
    display: inline-block;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .json-table .number {
    color: #ef4444;
    font-weight: 600;
  }

  .json-table .boolean-true {
    color: #10b981;
    font-weight: 600;
  }

  .json-table .boolean-false {
    color: #ef4444;
    font-weight: 600;
  }

  .table-output {
    width: 100%;
    height: 100%;
    overflow: auto;
  }

  /* ç§»åŠ¨ç«¯ç‰¹æ®ŠæŒ‰é’®æ ·å¼ */
  #apply-extract {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  }

  #apply-extract:hover {
    background: linear-gradient(135deg, #059669 0%, #047857 100%);
  }

  /* ç§»åŠ¨ç«¯æŒ‰é’®ç»„å¸ƒå±€ä¼˜åŒ– */
  @media (max-width: 768px) {
    .output-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-auto-flow: dense;
      gap: 4px;
    }

    .output-controls button,
    .output-controls select {
      min-height: 36px;
      font-size: 12px;
      padding: 8px 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* æœ€åä¸‰ä¸ªæŒ‰é’®ï¼ˆæ¸…ç©ºã€å†å²è®°å½•ã€å­—ä½“å¤§å°é€‰æ‹©ï¼‰åœ¨ç§»åŠ¨ç«¯å°å±å¹•æƒ…å†µä¸‹å¹¶æ’æ˜¾ç¤º */
    #clear-btn,
    #history-btn,
    #font-size-select {
      grid-column: auto;
      grid-row: span 1;
      flex: 1;
      width: auto;
      min-width: 0;
    }
  }

  /* ä¸­æ–‡é¡µé¢æŒ‰é’®å¸ƒå±€ä¼˜åŒ– - é•¿æ–‡å­—éœ€è¦æ›´å¤šç©ºé—´ */
  [lang="zh-CN"] .output-controls {
    grid-template-columns: repeat(2, 1fr);
  }

  [lang="zh-CN"] .output-controls button {
    font-size: 11px;
    padding: 6px 8px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [lang="zh-CN"] #history-btn {
    grid-column: span 1;
  }

  @media (max-width: 480px) {
    .output-controls {
      gap: 3px;
    }

    .output-controls button {
      min-height: 32px;
      font-size: 11px;
      padding: 4px 6px;
    }

    .output-controls select {
      min-height: 32px;
      font-size: 11px;
      padding: 4px 6px;
    }
  }

  /* ä¸­æ–‡é¡µé¢è¶…å°å±å¹•ä¼˜åŒ– */
  @media (max-width: 480px) {
    [lang="zh-CN"] .output-controls button {
      font-size: 10px;
      padding: 4px 6px;
    }
  }

  /* å³ä¾§è¾“å‡ºåŒºåŸŸ */
  .output-area {
    width: 0;
    opacity: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 1px solid transparent;
  }

  .output-area.expanded {
    width: 50%;
    opacity: 1;
    border-left: 1px solid #e5e7eb;
    padding-left: 0;
  }

  .output-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
    border-radius: 6px 6px 0 0;
    border: 1px solid #e9ecef;
    border-bottom: none;
  }

  .output-title {
    font-size: 0.85rem;
    font-weight: 600;
    color: #6b7280;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .close-output-btn {
    background: none;
    border: none;
    font-size: 24px;
    color: #9ca3af;
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s;
    line-height: 1;
  }

  .close-output-btn:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #dc2626;
  }

  /* è¾“å‡ºå†…å®¹åŒºåŸŸï¼Œä¸è¾“å…¥æ¡†ç›¸åŒæ ·å¼ */
  .output-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .output-editor-wrapper {
    display: flex;
    border: 1px solid #e1e4e8;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
    flex: 1;
    background: linear-gradient(to bottom, #fafbfc 0%, #f5f6f8 100%);
  }

  #output-json {
    flex: 1;
    padding: 12px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 13px;
    line-height: 1.5;
    overflow: auto;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    min-height: 0;
  }

  /* JSONæ ‘å½¢æŸ¥çœ‹å™¨æ ·å¼ */
  .json-root {
    padding: 5px 0;
  }

  .json-bracket {
    padding: 0 5px;
  }

  .json-node {
    margin-left: 18px;
  }

  .json-property {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 2px 0;
    border-radius: 3px;
    transition: background 0.1s;
  }

  .json-property:hover {
    background: rgba(59, 130, 246, 0.05);
  }

  .json-toggle {
    display: inline-block;
    width: 14px;
    height: 14px;
    text-align: center;
    line-height: 12px;
    cursor: pointer;
    border: 1px solid #d1d5db;
    border-radius: 3px;
    margin-right: 6px;
    font-size: 10px;
    user-select: none;
    background: #fff;
    color: #6b7280;
    transition: all 0.15s;
  }

  .json-toggle:hover {
    border-color: #3b82f6;
    color: #3b82f6;
  }

  .json-key {
    color: #7c3aed;
    margin-right: 6px;
    font-weight: 500;
  }

  .json-separator {
    margin-right: 6px;
    color: #94a3b8;
  }

  .json-value-string {
    color: #059669;
  }

  .json-value-number {
    color: #dc2626;
  }

  .json-value-boolean {
    color: #2563eb;
  }

  .json-value-null {
    color: #9ca3af;
  }

  .json-value-object,
  .json-value-array {
    color: #1f2937;
  }

  .collapsed > .json-node {
    display: none;
  }

  /* Tutorial Section */
  .tutorial-section {
    max-width: 1800px;
    margin: 60px auto 0;
    padding: 40px 20px;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  }

  .tutorial-section .section-header,
  .faq-section .section-header {
    text-align: center;
    margin-bottom: 40px;
  }

  .tutorial-section .section-header h2,
  .faq-section .section-header h2 {
    font-size: 2.5rem;
    font-weight: 800;
    color: #1e293b;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .tutorial-section .section-header p,
  .faq-section .section-header p {
    font-size: 1.1rem;
    color: #64748b;
  }

  .tutorial-container {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 32px;
  }

  .tutorial-step {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    background: white;
    padding: 24px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 4px solid transparent;
  }

  .tutorial-step:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    border-left-color: #3b82f6;
  }

  .step-number {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 1.125rem;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }

  .step-content {
    flex: 1;
  }

  .step-content h3 {
    font-size: 1.25rem;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .step-content p {
    color: #475569;
    line-height: 1.7;
    margin-bottom: 12px;
    font-size: 0.9375rem;
  }

  .step-content p:last-child {
    margin-bottom: 0;
  }

  .step-example {
    background: #1e293b;
    border-radius: 8px;
    padding: 16px;
    margin: 12px 0;
    overflow-x: auto;
  }

  .step-example code {
    color: #e2e8f0;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.6;
    white-space: pre;
  }

  .example-desc {
    color: #64748b;
    font-size: 0.875rem;
    font-style: italic;
    margin-top: 8px;
  }

  .tip {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border-left: 4px solid #f59e0b;
    padding: 12px 16px;
    border-radius: 6px;
    margin-top: 12px;
    font-size: 0.875rem;
    color: #92400e;
  }

  .privacy-note {
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border-left: 4px solid #3b82f6;
    padding: 12px 16px;
    border-radius: 6px;
    margin-top: 12px;
    font-size: 0.875rem;
    color: #1e40af;
  }

  .action-list {
    list-style: none;
    padding: 0;
    margin: 12px 0 0 0;
  }

  .action-list li {
    padding: 8px 0;
    padding-left: 24px;
    position: relative;
    color: #475569;
    font-size: 0.9375rem;
    line-height: 1.6;
  }

  .action-list li::before {
    content: 'âœ“';
    position: absolute;
    left: 0;
    color: #3b82f6;
    font-weight: 700;
  }

  .action-list li strong {
    color: #0f172a;
    font-weight: 600;
  }

  /* Features Section - åˆ›æ„æ¸å˜æ•ˆæœ */
  .features-section {
    max-width: 1800px;
    margin: 60px auto 0;
    padding: 60px 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 20px;
    position: relative;
    overflow: hidden;
  }

  .features-section::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
    animation: rotate 20s linear infinite;
  }

  @keyframes rotate {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  .features-section .section-header {
    text-align: center;
    margin-bottom: 50px;
    position: relative;
    z-index: 1;
  }

  .features-section .section-header h2 {
    font-size: 2.5rem;
    font-weight: 800;
    color: white;
    margin-bottom: 12px;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  }

  .features-section .section-header p {
    font-size: 1.1rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .features-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 30px;
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    z-index: 1;
  }

  .feature-item {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 0;
    position: relative;
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  }

  .feature-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .feature-item:hover::before {
    transform: scaleX(1);
  }

  .feature-item:hover {
    transform: translateY(-8px) rotateX(2deg);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
  }

  .feature-number {
    font-size: 4rem;
    font-weight: 900;
    color: rgba(102, 126, 234, 0.08);
    position: absolute;
    top: -10px;
    right: 10px;
    line-height: 1;
    transition: all 0.4s ease;
  }

  .feature-item:hover .feature-number {
    color: rgba(102, 126, 234, 0.15);
    transform: scale(1.1);
  }

  .feature-content {
    padding: 32px;
    position: relative;
    z-index: 1;
  }

  .feature-icon {
    font-size: 3rem;
    margin-bottom: 20px;
    display: inline-block;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
  }

  .feature-item:hover .feature-icon {
    transform: scale(1.2) rotate(5deg);
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
  }

  .feature-content h3 {
    font-size: 1.35rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 12px;
    transition: color 0.3s ease;
  }

  .feature-item:hover .feature-content h3 {
    color: #667eea;
  }

  .feature-content p {
    color: #64748b;
    line-height: 1.7;
    font-size: 0.95rem;
  }

  /* Supported Formats Section */
  .supported-formats-section {
    max-width: 1800px;
    margin: 60px auto 0;
    padding: 50px 20px;
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
  }

  .supported-formats-section .section-header {
    text-align: center;
    margin-bottom: 45px;
  }

  .supported-formats-section .section-header h2 {
    font-size: 2.2rem;
    font-weight: 800;
    color: #0f172a;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .supported-formats-section .section-header p {
    font-size: 1.1rem;
    color: #64748b;
  }

  .formats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 24px;
    max-width: 1200px;
    margin: 0 auto;
  }

  .format-category {
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.06);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid #e0f2fe;
  }

  .format-category:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(14, 165, 233, 0.15);
    border-color: #0ea5e9;
  }

  .format-category h3 {
    font-size: 1.2rem;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #e0f2fe;
  }

  .format-category ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .format-category li {
    padding: 8px 0;
    padding-left: 24px;
    position: relative;
    color: #475569;
    font-size: 0.9rem;
    line-height: 1.6;
  }

  .format-category li::before {
    content: 'âœ“';
    position: absolute;
    left: 0;
    color: #0ea5e9;
    font-weight: 700;
  }

  .formats-note {
    max-width: 900px;
    margin: 35px auto 0;
    padding: 18px 24px;
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border-left: 4px solid #3b82f6;
    border-radius: 8px;
    font-size: 0.95rem;
    color: #1e40af;
    line-height: 1.7;
  }

  .formats-note strong {
    font-weight: 700;
    color: #1e3a8a;
  }

  /* FAQ Section - 2åˆ—å±•å¼€æ ·å¼ */
  .faq-section {
    max-width: 1800px;
    margin: 60px auto 40px;
    padding: 40px 20px;
    background: transparent;
    border-radius: 0;
    border: none;
  }

  .faq-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 32px;
    max-width: 1200px;
    margin: 0 auto;
  }

  .faq-item {
    padding: 0;
    background: transparent;
    border-radius: 0;
    border: none;
    border-left: 3px solid #3b82f6;
    padding-left: 20px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .faq-item:hover {
    border-left-color: #2563eb;
    padding-left: 24px;
  }

  .faq-item h3 {
    font-size: 1.15rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 12px;
  }

  .faq-item p {
    color: #64748b;
    line-height: 1.7;
    font-size: 0.95rem;
  }

/* å“åº”å¼è®¾è®¡ */
  @media (max-width: 1200px) {
    .output-area.expanded {
      width: 60%;
    }
  }

  @media (max-width: 768px) {
    .json-formatter-container {
      padding: 6px;
      height: calc(100vh - var(--sidebar-height, 40px));
      flex-shrink: 0;
    }

    .editor-workspace {
      flex-direction: column;
    }

    .input-area {
      gap: 8px;
      min-height: 300px;
      max-width: 100%;
    }

    .monaco-editor-container {
      min-height: 250px;
    }

    /* ç§»åŠ¨ç«¯æ¯”è¾ƒæ¨¡å¼ä¼˜åŒ– */
    .editors-wrapper.compare-mode {
      flex-direction: column;
      gap: 8px;
    }

    .editors-wrapper.compare-mode .input-section {
      min-height: 200px;
    }

    /* ç§»åŠ¨ç«¯ç¼–è¾‘å™¨å®¹å™¨ä¼˜åŒ– */
    .input-editor-wrapper {
      min-height: 200px;
    }

    .extraction-controls {
      flex-wrap: wrap;
      gap: 6px;
    }

    .extraction-controls input {
      min-width: 100%;
      margin-bottom: 6px;
    }

    .extraction-controls label {
      width: 100%;
      margin-bottom: 4px;
    }

    .json-input {
      min-height: 200px;
    }

    .output-controls {
      gap: 4px;
      flex-wrap: wrap;
    }

    .output-controls button {
      padding: 8px 12px;
      font-size: 12px;
      flex: 1;
      min-width: 70px;
      height: 36px;
    }

    .output-controls select {
      flex: 1;
      min-width: 90px;
      height: 36px;
      padding: 8px 12px;
    }

    .output-area.expanded {
      width: 100%;
      border-left: none;
      padding-left: 0;
      margin-top: 12px;
      height: 350px;
    }

    /* ç§»åŠ¨ç«¯Monaco Editorä¼˜åŒ– */
    .monaco-editor-container {
      min-height: 200px;
    }

    /* ç§»åŠ¨ç«¯å·®å¼‚é«˜äº®ä¼˜åŒ– */
    .monaco-editor .diff-removed-decoration,
    .monaco-editor .diff-added-decoration,
    .monaco-editor .diff-changed-decoration {
      background-color: rgba(var(--diff-opacity), 0.3) !important;
      border-left-width: 3px !important;
    }

    /* ç§»åŠ¨ç«¯ç¼–è¾‘å™¨è§¦æ‘¸ä¼˜åŒ– */
    .monaco-editor {
      touch-action: pan-y;
    }

    .monaco-editor .margin {
      touch-action: none;
    }

    /* ç§»åŠ¨ç«¯æå–åŒºåŸŸä¼˜åŒ– */
    .extraction-section {
      padding: 8px;
    }

    .extraction-controls {
      gap: 8px;
    }

    .extraction-controls input {
      padding: 8px 12px;
      font-size: 14px;
      min-height: 40px;
    }

    .extraction-controls button {
      min-height: 40px;
      padding: 8px 16px;
      font-size: 14px;
    }

    /* Tutorial section ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .tutorial-step {
      flex-direction: column;
      padding: 16px;
    }

    .step-number {
      margin-bottom: 12px;
    }

    .section-header {
      padding: 20px 12px;
    }

    .section-header h2 {
      font-size: 1.5rem;
    }

    /* Features ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .features-grid {
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 12px;
    }

    /* Supported Formats ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .formats-grid {
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 12px;
    }

    .format-category {
      padding: 18px;
    }

    .formats-note {
      margin: 25px 12px 0;
      padding: 14px 18px;
      font-size: 0.9rem;
    }

    /* FAQ ç§»åŠ¨ç«¯ä¼˜åŒ– */
    .faq-grid {
      grid-template-columns: 1fr;
      gap: 24px;
      padding: 0 12px;
    }

    .faq-item {
      border-left-width: 2px;
      padding-left: 16px;
    }

    .faq-item:hover {
      padding-left: 18px;
    }
  }

  @media (max-width: 480px) {
    .json-formatter-container {
      padding: 4px;
    }

    .input-area {
      gap: 6px;
    }

    .output-controls {
      gap: 3px;
    }

    .output-controls button {
      flex: 1;
      min-width: 0;
      padding: 6px 8px;
      font-size: 11px;
      height: 32px;
    }

    .output-controls select {
      height: 32px;
      padding: 6px 8px;
      font-size: 11px;
    }

    .json-action-group {
      flex: 1;
    }

    .json-input {
      min-height: 150px;
      font-size: 12px;
    }

    .extraction-section {
      padding: 6px;
    }

    .monaco-editor-container {
      min-height: 150px;
    }

    /* è¶…å°å±å¹•æ¯”è¾ƒæ¨¡å¼ä¼˜åŒ– */
    .editors-wrapper.compare-mode .input-section {
      min-height: 150px;
    }

    .input-editor-wrapper {
      min-height: 150px;
    }
  }

  /* ç§»åŠ¨ç«¯æ¨ªå±ä¼˜åŒ– */
  /* ISON & TOON Feature Section (Global) */
  .ison-feature-section {
    padding: 60px 20px;
    background: linear-gradient(135deg, #f0f9ff 0%, #faf5ff 100%);
    margin: 40px 0;
    border-radius: 16px;
  }

  .ison-feature-section .section-header {
    max-width: 920px;
    margin: 0 auto 28px;
    text-align: center;
    background: rgba(255, 255, 255, 0.75);
    border: 1px solid rgba(147, 197, 253, 0.45);
    border-radius: 14px;
    padding: 20px 22px;
    box-shadow: 0 6px 20px rgba(15, 23, 42, 0.06);
    backdrop-filter: blur(4px);
  }

  .ison-feature-section .section-header h2 {
    font-size: clamp(1.35rem, 2.5vw, 2rem);
    line-height: 1.25;
    color: #0f172a;
    margin: 0 0 8px;
  }

  .ison-feature-section .section-header p {
    margin: 0;
    color: #475569;
    font-size: 1rem;
    line-height: 1.6;
  }

  .ison-grid {
    max-width: 1200px;
    margin: 32px auto 0;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 24px;
  }

  .ison-card {
    background: white;
    padding: 28px;
    border-radius: 14px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
    transition: all 0.25s ease;
    border: 1px solid #e5e7eb;
  }

  .ison-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.12);
    border-color: #93c5fd;
  }

  .ison-icon {
    font-size: 2rem;
    text-align: center;
    margin-bottom: 12px;
  }

  .ison-card h3 {
    font-size: 1.25rem;
    font-weight: 700;
    text-align: center;
    margin: 10px 0;
    color: #0f172a;
  }

  .ison-card p {
    text-align: center;
    color: #64748b;
    line-height: 1.6;
    margin-bottom: 16px;
  }

  .ison-features {
    list-style: none;
    padding: 0;
    margin: 0 0 16px 0;
  }

  .ison-features li {
    padding: 6px 0;
    color: #475569;
    font-size: 0.9375rem;
  }

  .ison-action-btn,
  .ison-link {
    display: block;
    text-align: center;
    padding: 10px 18px;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    color: #fff;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    transition: all 0.2s;
  }

  .ison-action-btn:hover,
  .ison-link:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
  }

  @media (max-width: 768px) {
    .ison-feature-section {
      padding: 40px 16px;
      margin: 24px 0;
    }

    .ison-feature-section .section-header {
      padding: 14px 12px;
      margin-bottom: 18px;
      border-radius: 10px;
    }

    .ison-feature-section .section-header h2 {
      font-size: 1.15rem;
      margin-bottom: 6px;
    }

    .ison-feature-section .section-header p {
      font-size: 0.9rem;
    }

    .ison-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .ison-card {
      padding: 20px;
    }
  }
  @media (max-width: 768px) and (orientation: landscape) {
    .json-formatter-container {
      height: calc(100vh - 20px);
    }

    .input-area {
      min-height: 200px;
    }

    .monaco-editor-container {
      min-height: 180px;
    }

    .editors-wrapper.compare-mode .input-section {
      min-height: 160px;
    }

    .output-area.expanded {
      height: 250px;
    }
  }

  /* ISON & TOON è¯¦ç»†éƒ¨åˆ†æ ·å¼ */
  .ison-detailed-section,
  .toon-detailed-section {
    padding: 80px 20px;
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
  }

  .toon-detailed-section {
    background: linear-gradient(135deg, #fefce8 0%, #fef3c7 100%);
  }

  .section-header {
    text-align: center;
    margin-bottom: 60px;
  }

  .section-tag {
    display: inline-block;
    padding: 8px 16px;
    background: #dbeafe;
    color: #1e40af;
    border-radius: 20px;
    font-weight: 600;
    font-size: 0.875rem;
    margin-bottom: 16px;
  }

  .section-title {
    font-size: 2.5rem;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 16px;
  }

  .section-subtitle {
    font-size: 1.125rem;
    color: #64748b;
    max-width: 700px;
    margin: 0 auto;
    line-height: 1.7;
  }

  .ison-content-grid,
  .toon-content-grid {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    gap: 60px;
  }

  .content-block {
    background: white;
    padding: 40px;
    border-radius: 16px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }

  .content-title {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 20px;
  }

  .content-description {
    color: #475569;
    line-height: 1.8;
    margin-bottom: 30px;
  }

  .code-example {
    background: #1e293b;
    color: #e2e8f0;
    padding: 24px;
    border-radius: 8px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 0.875rem;
    overflow-x: auto;
    margin: 20px 0;
  }

  .token-comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin: 30px 0;
  }

  .token-comparison-table th,
  .token-comparison-table td {
    padding: 16px;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
  }

  .token-comparison-table th {
    background: #f1f5f9;
    font-weight: 700;
    color: #0f172a;
  }

  .token-savings {
    color: #16a34a;
    font-weight: 700;
  }

  .format-structure {
    background: #fef3c7;
    border-left: 4px solid #f59e0b;
    padding: 20px;
    margin: 20px 0;
    border-radius: 8px;
  }

  .use-case-list {
    list-style: none;
    padding: 0;
  }

  .use-case-list li {
    padding: 12px 0;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    align-items: start;
  }

  .use-case-list li:before {
    content: "âœ“";
    color: #16a34a;
    font-weight: 700;
    margin-right: 12px;
    font-size: 1.25rem;
  }

  /* æ ¼å¼å¯¹æ¯”éƒ¨åˆ† */
  .format-comparison-section {
    padding: 80px 20px;
    background: white;
  }

  .comparison-grid {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 30px;
  }

  .comparison-card {
    padding: 40px 30px;
    border-radius: 16px;
    text-align: center;
    transition: transform 0.2s;
  }

  .comparison-card:hover {
    transform: translateY(-8px);
  }

  .comparison-card.ison {
    background: linear-gradient(135deg, #dbeafe 0%, #93c5fd 100%);
  }

  .comparison-card.toon {
    background: linear-gradient(135deg, #fef3c7 0%, #fcd34d 100%);
  }

  .comparison-card.json {
    background: linear-gradient(135deg, #f1f5f9 0%, #cbd5e1 100%);
  }

  .comparison-badge {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 700;
    margin-bottom: 16px;
  }

  .comparison-card.ison .comparison-badge {
    background: #1e40af;
    color: white;
  }

  .comparison-card.toon .comparison-badge {
    background: #b45309;
    color: white;
  }

  .comparison-card.json .comparison-badge {
    background: #475569;
    color: white;
  }

  .comparison-card h3 {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 12px;
    color: #0f172a;
  }

  .comparison-card .token-saving {
    font-size: 2rem;
    font-weight: 800;
    margin: 20px 0;
  }

  .comparison-card.ison .token-saving {
    color: #16a34a;
  }

  .comparison-card.toon .token-saving {
    color: #b45309;
  }

  .comparison-card.json .token-saving {
    color: #64748b;
  }

  .comparison-card p {
    color: #475569;
    line-height: 1.7;
  }

  /* FAQ éƒ¨åˆ† */
  .faq-section {
    padding: 80px 20px;
    background: #f8fafc;
  }

  .faq-grid {
    max-width: 900px;
    margin: 0 auto;
  }

  .faq-item {
    background: white;
    margin-bottom: 16px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  .faq-question {
    padding: 24px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
    color: #0f172a;
    user-select: none;
    transition: background 0.2s;
  }

  .faq-question:hover {
    background: #f8fafc;
  }

  .faq-question:after {
    content: "+";
    font-size: 1.5rem;
    color: #3b82f6;
    font-weight: 700;
  }

  .faq-item.active .faq-question:after {
    content: "âˆ’";
  }

  .faq-answer {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
    padding: 0 24px;
  }

  .faq-item.active .faq-answer {
    max-height: 500px;
    padding: 0 24px 24px;
  }

  .faq-answer p {
    color: #475569;
    line-height: 1.7;
    padding-top: 8px;
  }

  /* å“åº”å¼æ ·å¼ */
  @media (max-width: 768px) {
    .ison-detailed-section,
    .toon-detailed-section,
    .format-comparison-section,
    .faq-section {
      padding: 60px 16px;
    }

    .section-title {
      font-size: 2rem;
    }

    .content-block {
      padding: 24px;
    }

    .comparison-grid {
      grid-template-columns: 1fr;
    }

    .token-comparison-table {
      font-size: 0.875rem;
    }

    .token-comparison-table th,
    .token-comparison-table td {
      padding: 12px 8px;
    }
  }
</style>

<script type="module">
  // é…ç½® Monaco Editor çš„èµ„æºè·¯å¾„
  window.MonacoEnvironment = {
    getWorkerUrl: function (workerId, label) {
      return `https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/base/workers/${label === 'json' ? 'json.worker' : 'editor.worker'}.js`;
    }
  };

  // ä½¿ç”¨ CDN å¯¼å…¥ Monaco Editor
  import * as monaco from 'https://esm.sh/monaco-editor@0.45.0';

  // é…ç½® Monaco Editor
  monaco.editor.setTheme('vs');

  // å…¨å±€å˜é‡
  let editor = null;
  let outputEditor = null;
  let compareEditor = null;
  let translations = {};
  let isCompareMode = false;
  let leftDecorations = [];
  let rightDecorations = [];

  // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
  document.addEventListener('DOMContentLoaded', () => {
    // ä»DOMå…ƒç´ è·å–ç¿»è¯‘æ–‡æœ¬
    const container = document.querySelector('.json-formatter-container');
    translations = {
      enterExtractionFn: container.dataset.enterExtractionFn,
      enterData: container.dataset.enterData,
      extractionError: container.dataset.extractionError,
      parsingError: container.dataset.parsingError,
      compressSuccess: container.dataset.compressSuccess,
      escapeSuccess: container.dataset.escapeSuccess,
      xmlSuccess: container.dataset.xmlSuccess,
      tsSuccess: container.dataset.tsSuccess,
      csvSuccess: container.dataset.csvSuccess,
      excelSuccess: container.dataset.excelSuccess
    };

    // åˆå§‹åŒ– Monaco Editor
    initializeMonacoEditor();

    initializeJsonFormatter();

    // åˆå§‹åŒ– FAQ åŠŸèƒ½
    initializeFaq();
  });

  // FAQ äº¤äº’åŠŸèƒ½
  function initializeFaq() {
    const faqItems = document.querySelectorAll('.faq-item');
    faqItems.forEach(item => {
      const question = item.querySelector('.faq-question');
      if (question) {
        question.addEventListener('click', () => {
          // å…³é—­å…¶ä»–æ‰“å¼€çš„ FAQ
          faqItems.forEach(otherItem => {
            if (otherItem !== item) {
              otherItem.classList.remove('active');
            }
          });
          // åˆ‡æ¢å½“å‰ FAQ
          item.classList.toggle('active');
        });
      }
    });
  }

  // åˆå§‹åŒ– Monaco Editor
  function initializeMonacoEditor() {
    const container = document.getElementById('monaco-editor-container');
    if (!container) {
      console.error('Monaco Editor container not found');
      return;
    }

    // ç­‰å¾…é¡µé¢å®Œå…¨æ¸²æŸ“ï¼ŒåŒ…æ‹¬ CSS æ ·å¼åº”ç”¨
    // ä½¿ç”¨åŒé‡ requestAnimationFrame ç¡®ä¿æµè§ˆå™¨å®Œæˆå¸ƒå±€è®¡ç®—
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        // ç¡®ä¿å®¹å™¨æœ‰æ­£ç¡®çš„å°ºå¯¸
        console.log('Container dimensions:', {
          width: container.offsetWidth,
          height: container.offsetHeight
        });

        // å¦‚æœå®¹å™¨å°ºå¯¸è¿˜æ˜¯å¼‚å¸¸ï¼Œå†å»¶è¿Ÿä¸€ç‚¹
        if (container.offsetWidth === 0 || container.offsetHeight === 0) {
          setTimeout(() => createEditor(container), 50);
        } else {
          createEditor(container);
        }
      });
    });
  }

  // åˆ›å»º Monaco Editor
  function createEditor(container) {
    // è·å–ä¿å­˜çš„å­—ä½“å¤§å°
    const savedFontSize = localStorage.getItem('editorFontSize') || '13';

    // åˆ›å»ºè¾“å…¥ç¼–è¾‘å™¨
    editor = monaco.editor.create(container, {
      value: '',
      language: 'json',
      theme: 'vs',
      automaticLayout: true,
      fontSize: parseInt(savedFontSize),
      fontFamily: "'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
      lineHeight: 21,
      minimap: { enabled: false },
      scrollBeyondLastLine: false,
      wordWrap: 'off',
      // è¡Œå·é…ç½®
      lineNumbers: 'on',
      lineNumbersMinChars: 3,
      // æŠ˜å é…ç½®
      folding: true,
      foldingStrategy: 'indentation',
      foldingHighlight: true,
      showFoldingControls: 'always',
      // å…¶ä»–é…ç½®
      matchBrackets: 'always',
      autoClosingBrackets: 'always',
      autoClosingQuotes: 'always',
      formatOnPaste: true,
      formatOnType: true,
      tabSize: 2,
      renderLineHighlight: 'all',
      scrollbar: {
        vertical: 'visible',
        horizontal: 'visible'
      },
      padding: { top: 12, bottom: 12 },
      readOnly: false
    });

    console.log('Monaco Editor created successfully');

    // åˆ›å»ºè¾“å‡ºç¼–è¾‘å™¨
    const outputContainer = document.getElementById('output-monaco-container');
    if (outputContainer) {
      outputEditor = monaco.editor.create(outputContainer, {
        value: '',
        language: 'json',
        theme: 'vs',
        automaticLayout: true,
        fontSize: parseInt(savedFontSize),
        fontFamily: "'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
        lineHeight: 21,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        wordWrap: 'off',
        lineNumbers: 'on',
        lineNumbersMinChars: 3,
        folding: true,
        foldingStrategy: 'indentation',
        foldingHighlight: true,
        showFoldingControls: 'always',
        matchBrackets: 'always',
        tabSize: 2,
        renderLineHighlight: 'all',
        scrollbar: {
          vertical: 'visible',
          horizontal: 'visible'
        },
        padding: { top: 12, bottom: 12 },
        readOnly: true  // è¾“å‡ºç¼–è¾‘å™¨åªè¯»
      });
      console.log('Output Monaco Editor created successfully');
    }

    // åˆ›å»ºæ¯”è¾ƒç¼–è¾‘å™¨
    const compareContainer = document.getElementById('monaco-compare-container');
    if (compareContainer) {
      compareEditor = monaco.editor.create(compareContainer, {
        value: '',
        language: 'json',
        theme: 'vs',
        automaticLayout: true,
        fontSize: parseInt(savedFontSize),
        fontFamily: "'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
        lineHeight: 21,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        wordWrap: 'off',
        lineNumbers: 'on',
        lineNumbersMinChars: 3,
        folding: true,
        foldingStrategy: 'indentation',
        foldingHighlight: true,
        showFoldingControls: 'always',
        matchBrackets: 'always',
        autoClosingBrackets: 'always',
        autoClosingQuotes: 'always',
        formatOnPaste: true,
        formatOnType: true,
        tabSize: 2,
        renderLineHighlight: 'all',
        scrollbar: {
          vertical: 'visible',
          horizontal: 'visible'
        },
        padding: { top: 12, bottom: 12 },
        readOnly: false
      });
      console.log('Compare Monaco Editor created successfully');

      // ç›‘å¬æ¯”è¾ƒç¼–è¾‘å™¨å†…å®¹å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°å·®å¼‚é«˜äº®
      compareEditor.onDidChangeModelContent(() => {
        if (isCompareMode) {
          highlightDifferences();
        }
      });
    }

    // è°ƒè¯•ï¼šæ£€æŸ¥ DOM ç»“æ„
    setTimeout(() => {
      const monacoContainer = container.querySelector('.monaco-editor');
      if (monacoContainer) {
        const margin = monacoContainer.querySelector('.margin');
        console.log('Monaco DOM structure:', {
          container: container.offsetWidth,
          monacoEditor: monacoContainer.offsetWidth,
          margin: margin ? margin.offsetWidth : 'NOT FOUND',
          marginVisible: margin ? window.getComputedStyle(margin).display : 'N/A'
        });
      }
    }, 200);

    // å¼ºåˆ¶æ›´æ–°å¸ƒå±€
    setTimeout(() => {
      if (editor) {
        editor.layout();
        console.log('Monaco Editor layout updated');
      }
    }, 100);

    // ç›‘å¬å†…å®¹å˜åŒ–ï¼Œè‡ªåŠ¨æ ¼å¼åŒ–å’Œä¿å­˜å†å²
    editor.onDidChangeModelContent(() => {
      clearTimeout(window.autoFormatTimeout);
      window.autoFormatTimeout = setTimeout(autoFormatJson, 500);

      // å¦‚æœåœ¨æ¯”è¾ƒæ¨¡å¼ï¼Œæ›´æ–°å·®å¼‚é«˜äº®
      if (isCompareMode) {
        highlightDifferences();
      }

      // æ§åˆ¶æç¤ºæ˜¾ç¤º/éšè—
      const hint = document.getElementById('editor-hint');
      if (hint) {
        const hasContent = getEditorContent().trim().length > 0;
        if (hasContent) {
          hint.classList.add('hint-hidden');
        } else {
          hint.classList.remove('hint-hidden');
        }
      }
    });

    // ç›‘å¬ JSON é”™è¯¯æ ‡è®°å˜åŒ–
    monaco.editor.onDidChangeMarkers(() => {
      const errorElement = document.getElementById('json-validation-error');
      if (!errorElement) return;

      const model = editor.getModel();
      if (!model) return;

      const modelMarkers = model.getAllMarkers();
      if (modelMarkers.length === 0) {
        // æ²¡æœ‰é”™è¯¯ï¼Œéšè—æç¤º
        errorElement.classList.remove('show');
        errorElement.textContent = '';
      } else {
        // æœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªé”™è¯¯
        const firstError = modelMarkers[0];
        const line = model.getLineContent(firstError.startLineNumber);
        const errorInfo = firstError.message;

        // è·å–å½“å‰è¯­è¨€
        const currentLang = window.appState.lang || 'en';
        const errorMessage = currentLang === 'zh'
          ? `ç¬¬ ${firstError.startLineNumber} è¡Œé”™è¯¯ï¼š${errorInfo}`
          : `Line ${firstError.startLineNumber} error: ${errorInfo}`;

        errorElement.textContent = errorMessage;
        errorElement.classList.add('show');
      }
    });
  }

  // è·å–ç¼–è¾‘å™¨ä¸­çš„æ–‡æœ¬
  function getEditorContent() {
    return editor ? editor.getValue() : '';
  }

  // è®¾ç½®ç¼–è¾‘å™¨ä¸­çš„æ–‡æœ¬
  function setEditorContent(content) {
    if (editor) {
      editor.setValue(content);
    }
  }

  // ============ è¾“å…¥ç±»å‹æ£€æµ‹å’Œè§£æå‡½æ•° ============

  // æ£€æµ‹è¾“å…¥ç±»å‹
  function detectInputType(inputText) {
    const trimmed = inputText.trim();

    // æ£€æµ‹æ˜¯å¦ä¸ºURLå‚æ•°
    if (trimmed.includes('?') || /^\w+=/.test(trimmed)) {
      return 'urlparams';
    }

    // æ£€æµ‹æ˜¯å¦ä¸ºXML
    if (trimmed.startsWith('<?xml') || trimmed.startsWith('<!DOCTYPE') || /^<[\w-]+/.test(trimmed)) {
      return 'xml';
    }

    // æ£€æµ‹æ˜¯å¦ä¸ºYAML
    if (/^[\w-]+:\s*\n/.test(trimmed) || /^[\w-]+:\s*\S+/.test(trimmed)) {
      // ç®€å•çš„YAMLç‰¹å¾ï¼šåŒ…å«é”®å€¼å¯¹ï¼Œä½¿ç”¨å†’å·åˆ†éš”
      // æ’é™¤JSONï¼ˆJSONå·²ç»è¢«JSON.parseå¤„ç†è¿‡äº†ï¼‰
      try {
        JSON.parse(trimmed);
        return 'json';
      } catch {
        return 'yaml';
      }
    }

    // é»˜è®¤å°è¯•JSON
    return 'json';
  }

  // è§£æURLå‚æ•°ä¸ºJSONå¯¹è±¡
  function parseUrlParams(inputText) {
    const result = {};

    // ç§»é™¤URLå‰é¢çš„éƒ¨åˆ†ï¼Œåªä¿ç•™æŸ¥è¯¢å­—ç¬¦ä¸²
    let queryString = inputText.trim();
    const questionMarkIndex = queryString.indexOf('?');
    if (questionMarkIndex !== -1) {
      queryString = queryString.substring(questionMarkIndex + 1);
    }

    // åˆ†å‰²å‚æ•°
    const pairs = queryString.split('&');

    for (const pair of pairs) {
      if (!pair) continue;

      let [key, value] = pair.split('=');

      // è§£ç URLç¼–ç 
      if (key) {
        key = decodeURIComponent(key.replace(/\+/g, ' '));
      }
      if (value !== undefined) {
        value = decodeURIComponent(value.replace(/\+/g, ' '));
      } else {
        value = '';
      }

      // å°è¯•å°†å€¼è½¬æ¢ä¸ºæ•°å­—æˆ–å¸ƒå°”å€¼
      if (value === 'true') {
        value = true;
      } else if (value === 'false') {
        value = false;
      } else if (!isNaN(value) && value !== '') {
        const num = parseFloat(value);
        if (!isNaN(num)) {
          value = num;
        }
      }

      // å¤„ç†é‡å¤çš„é”®ï¼ˆè½¬æ¢ä¸ºæ•°ç»„ï¼‰
      if (key in result) {
        if (!Array.isArray(result[key])) {
          result[key] = [result[key]];
        }
        result[key].push(value);
      } else {
        result[key] = value;
      }
    }

    return result;
  }

  // è§£æXMLä¸ºJSONå¯¹è±¡
  function parseXml(inputText) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(inputText, 'text/xml');

    // æ£€æŸ¥è§£æé”™è¯¯
    const parseError = xmlDoc.getElementsByTagName('parsererror');
    if (parseError.length > 0) {
      throw new Error('Invalid XML format');
    }

    // é€’å½’è½¬æ¢XMLèŠ‚ç‚¹ä¸ºJSON
    function xmlTojson(node) {
      // æ–‡æœ¬èŠ‚ç‚¹
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        return text;
      }

      // å…ƒç´ èŠ‚ç‚¹
      if (node.nodeType === Node.ELEMENT_NODE) {
        const obj = {};

        // å¤„ç†å±æ€§
        if (node.attributes) {
          for (let i = 0; i < node.attributes.length; i++) {
            const attr = node.attributes[i];
            obj['@' + attr.name] = attr.value;
          }
        }

        // å¤„ç†å­èŠ‚ç‚¹
        const children = {};
        let hasChildren = false;

        for (let i = 0; i < node.childNodes.length; i++) {
          const child = node.childNodes[i];

          if (child.nodeType === Node.TEXT_NODE) {
            const text = child.textContent.trim();
            if (text) {
              // å¦‚æœåªæœ‰æ–‡æœ¬å†…å®¹ï¼Œç›´æ¥è¿”å›
              if (Object.keys(obj).length === 0) {
                return text;
              }
              obj['#text'] = text;
            }
          } else if (child.nodeType === Node.ELEMENT_NODE) {
            hasChildren = true;
            const childName = child.nodeName;
            const childValue = xmlTojson(child);

            if (childName in children) {
              // é‡å¤çš„èŠ‚ç‚¹è½¬æ¢ä¸ºæ•°ç»„
              if (!Array.isArray(children[childName])) {
                children[childName] = [children[childName]];
              }
              children[childName].push(childValue);
            } else {
              children[childName] = childValue;
            }
          }
        }

        // åˆå¹¶å±æ€§å’Œå­èŠ‚ç‚¹
        if (hasChildren) {
          Object.assign(obj, children);
        }

        // å¦‚æœåªæœ‰å±æ€§ï¼Œè¿”å›å¯¹è±¡
        // å¦‚æœå±æ€§ä¸ºç©ºä¸”åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œè¿”å›å­èŠ‚ç‚¹
        if (Object.keys(obj).length === 0) {
          return null;
        }

        return obj;
      }

      return null;
    }

    // ä»æ ¹å…ƒç´ å¼€å§‹è½¬æ¢
    const rootElement = xmlDoc.documentElement;
    const result = {};
    result[rootElement.nodeName] = xmlTojson(rootElement);

    return result;
  }

  // è§£æYAMLä¸ºJSONå¯¹è±¡ï¼ˆç®€åŒ–ç‰ˆï¼Œæ”¯æŒå¸¸ç”¨YAMLè¯­æ³•ï¼‰
  function parseYaml(inputText) {
    const lines = inputText.split('\n');
    const root = {};
    const stack = [{ obj: root, indent: -1 }];

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      const indent = line.search(/\S/);

      if (indent === -1) continue; // ç©ºè¡Œ

      // å›é€€åˆ°æ­£ç¡®çš„å±‚çº§
      while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
        stack.pop();
      }

      const current = stack[stack.length - 1].obj;

      // ç§»é™¤æ³¨é‡Š
      const commentIndex = line.indexOf('#');
      if (commentIndex !== -1) {
        line = line.substring(0, commentIndex);
      }

      // è§£æé”®å€¼å¯¹
      const colonIndex = line.indexOf(':');
      if (colonIndex === -1) continue;

      const key = line.substring(indent, colonIndex).trim();
      let valueStr = line.substring(colonIndex + 1).trim();

      // å¤„ç†ä¸åŒçš„å€¼ç±»å‹
      let value;
      if (!valueStr || valueStr === '') {
        // ç©ºå€¼ï¼Œå¯èƒ½æ˜¯å¯¹è±¡æˆ–æ•°ç»„çš„å¼€å§‹
        // æ£€æŸ¥ä¸‹ä¸€è¡Œæ¥åˆ¤æ–­
        if (i + 1 < lines.length) {
          const nextLine = lines[i + 1];
          const nextIndent = nextLine.search(/\S/);

          if (nextIndent > indent) {
            // ä¸‹ä¸€è¡Œç¼©è¿›æ›´å¤§ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå¯¹è±¡/æ•°ç»„
            value = nextLine.trim().startsWith('-') ? [] : {};
            stack.push({ obj: value, indent: indent });
          } else {
            value = null;
          }
        } else {
          value = null;
        }
      } else if (valueStr.startsWith('[') && valueStr.endsWith(']')) {
        // å†…è”æ•°ç»„
        try {
          value = JSON.parse(valueStr);
        } catch {
          value = valueStr;
        }
      } else if (valueStr.startsWith('{') && valueStr.endsWith('}')) {
        // å†…è”å¯¹è±¡
        try {
          value = JSON.parse(valueStr);
        } catch {
          value = valueStr;
        }
      } else if (valueStr === 'true' || valueStr === 'false') {
        // å¸ƒå°”å€¼
        value = valueStr === 'true';
      } else if (valueStr === 'null' || valueStr === '~') {
        // nullå€¼
        value = null;
      } else if (valueStr.startsWith('"') || valueStr.startsWith("'")) {
        // å¸¦å¼•å·çš„å­—ç¬¦ä¸²
        value = valueStr.slice(1, -1);
      } else if (!isNaN(valueStr)) {
        // æ•°å­—
        value = parseFloat(valueStr);
      } else if (valueStr.startsWith('|') || valueStr.startsWith('>')) {
        // å¤šè¡Œå­—ç¬¦ä¸²
        let multiLine = '';
        let j = i + 1;
        while (j < lines.length) {
          const nextLine = lines[j];
          const nextIndent = nextLine.search(/\S/);
          if (nextIndent <= indent) break;
          multiLine += (multiLine ? '\n' : '') + nextLine.trim();
          j++;
        }
        value = multiLine;
        i = j - 1;
      } else {
        // æ™®é€šå­—ç¬¦ä¸²
        value = valueStr;
      }

      // å¤„ç†æ•°ç»„é¡¹ï¼ˆä»¥-å¼€å¤´ï¼‰
      if (key.startsWith('-')) {
        const arrayKey = key.substring(1).trim();
        if (!Array.isArray(current)) {
          // è½¬æ¢å½“å‰å¯¹è±¡ä¸ºæ•°ç»„
          const temp = {};
          Object.assign(temp, current);
          const parentArray = [];
          if (Object.keys(temp).length > 0) {
            parentArray.push(temp);
          }
          // è¿™é‡Œéœ€è¦ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼Œç®€åŒ–å¤„ç†
          if (arrayKey) {
            if (Array.isArray(current)) {
              current.push({ [arrayKey]: value });
            } else {
              current[arrayKey] = value;
            }
          } else {
            if (Array.isArray(current)) {
              current.push(value);
            } else {
              const arr = [value];
              Object.assign(current, arr);
            }
          }
        }
      } else {
        current[key] = value;
      }
    }

    return root;
  }

  // è‡ªåŠ¨æ ¼å¼åŒ–å‡½æ•°
  function autoFormatJson() {
    const inputText = getEditorContent().trim();

    if (!inputText) {
      return;
    }

    try {
      // æ£€æµ‹è¾“å…¥ç±»å‹
      const inputType = detectInputType(inputText);

      let parsed;
      let converted = false;

      // æ ¹æ®ç±»å‹è§£æ
      if (inputType === 'json') {
        parsed = JSON.parse(inputText);
      } else if (inputType === 'urlparams') {
        parsed = parseUrlParams(inputText);
        converted = true;
      } else if (inputType === 'xml') {
        parsed = parseXml(inputText);
        converted = true;
      } else if (inputType === 'yaml') {
        parsed = parseYaml(inputText);
        converted = true;
      } else {
        // é»˜è®¤å°è¯•JSON
        parsed = JSON.parse(inputText);
      }

      // æ ¼å¼åŒ–JSON
      const formatted = JSON.stringify(parsed, null, 2);

      // åªæœ‰å½“æ ¼å¼åŒ–åçš„å†…å®¹ä¸å½“å‰ä¸åŒæ—¶æ‰æ›´æ–°
      if (formatted !== inputText) {
        // ä¿å­˜å½“å‰å…‰æ ‡ä½ç½®å’Œæ»šåŠ¨ä½ç½®
        const position = editor ? editor.getPosition() : null;
        const scrollTop = editor ? editor.getScrollTop() : null;

        // æ›´æ–°ç¼–è¾‘å™¨å†…å®¹
        setEditorContent(formatted);

        // æ¢å¤å…‰æ ‡ä½ç½®å’Œæ»šåŠ¨ä½ç½®
        if (position && editor) {
          editor.setPosition(position);
        }
        if (scrollTop !== null && editor) {
          editor.setScrollTop(scrollTop);
        }

        // å¦‚æœè½¬æ¢æˆåŠŸï¼Œæ˜¾ç¤ºæç¤º
        if (converted) {
          const typeNames = {
            'urlparams': 'URL Parameters',
            'xml': 'XML',
            'yaml': 'YAML'
          };
          showToast(`Converted from ${typeNames[inputType]} to JSON`);
        }
      }

      // ä¿å­˜åˆ°å†å²è®°å½•
      saveToHistory(formatted);
    } catch (e) {
      // è§£æå¤±è´¥ï¼Œä¸åšå¤„ç†
      console.debug('Parsing error:', e);
    }
  }

  // JSONæ ‘å½¢æŸ¥çœ‹å™¨
  class JsonViewer {
    constructor(containerId, data) {
      this.container = document.getElementById(containerId);
      if (!this.container) return;

      this.data = data;
      this.render();
      this.bindEvents();
    }

    render() {
      this.container.innerHTML = this.renderValue(this.data, '', true);
    }

    renderValue(value, key = '', hasNext = true) {
      if (value === null) {
        return this.renderProperty(key, `<span class="json-value-null">null</span>`, hasNext);
      }

      if (typeof value === 'object') {
        if (Array.isArray(value)) {
          return this.renderObjectOrArray(key, value, 'array', hasNext);
        } else {
          return this.renderObjectOrArray(key, value, 'object', hasNext);
        }
      }

      if (typeof value === 'string') {
        return this.renderProperty(key, `<span class="json-value-string">"${this.escapeHtml(value)}"</span>`, hasNext);
      }

      if (typeof value === 'number') {
        return this.renderProperty(key, `<span class="json-value-number">${value}</span>`, hasNext);
      }

      if (typeof value === 'boolean') {
        return this.renderProperty(key, `<span class="json-value-boolean">${value}</span>`, hasNext);
      }

      return this.renderProperty(key, value, hasNext);
    }

    renderProperty(key, value, hasNext) {
      if (key === '') {
        if (typeof value === 'object') {
          if (Array.isArray(value)) {
            return this.renderObjectContent(value, 'array');
          } else {
            return this.renderObjectContent(value, 'object');
          }
        }
        return `<div class="json-root">${value}${hasNext ? ',' : ''}</div>`;
      }

      return `
        <div class="json-property">
          <span class="json-toggle">â–¼</span>
          <span class="json-key">"${key}"</span>
          <span class="json-separator">:</span>
          <span class="json-value">${value}</span>
          ${hasNext ? '<span>,</span>' : ''}
        </div>
      `;
    }

    renderObjectOrArray(key, value, type, hasNext) {
      const length = Array.isArray(value) ? value.length : Object.keys(value).length;
      const displayName = type === 'array' ? `[${length}]` : `{${length}}`;

      return `
        <div class="json-property collapsible">
          <span class="json-toggle">â–¼</span>
          ${key ? `<span class="json-key">"${key}"</span><span class="json-separator">:</span>` : ''}
          <span class="json-value json-value-${type}">${displayName}</span>
          ${hasNext ? '<span>,</span>' : ''}
          <div class="json-node">${this.renderObjectContent(value)}</div>
        </div>
      `;
    }

    renderObjectContent(obj) {
      if (Array.isArray(obj)) {
        return `
          <div class="json-bracket">[</div>
          <div class="json-node">
            ${obj.map((item, index) => {
              const hasNext = index < obj.length - 1;
              return this.renderValue(item, '', hasNext);
            }).join('')}
          </div>
          <div class="json-bracket">]</div>
        `;
      } else {
        const entries = Object.entries(obj);
        return `
          <div class="json-bracket">{</div>
          <div class="json-node">
            ${entries.map(([key, value], index) => {
              const hasNext = index < entries.length - 1;
              return this.renderValue(value, key, hasNext);
            }).join('')}
          </div>
          <div class="json-bracket">}</div>
        `;
      }
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    bindEvents() {
      this.container.addEventListener('click', (e) => {
        const toggle = e.target.closest('.json-toggle');
        if (toggle) {
          this.toggleNode(toggle);
        }
      });
    }

    toggleNode(toggle) {
      const property = toggle.parentElement;
      property.classList.toggle('collapsed');

      if (property.classList.contains('collapsed')) {
        toggle.textContent = 'â–¶';
      } else {
        toggle.textContent = 'â–¼';
      }
    }
  }

  // å°† JsonViewer æš´éœ²åˆ°å…¨å±€
  window.JsonViewer = JsonViewer;

  // å±•å¼€è¾“å‡ºåŒºåŸŸ
  function expandOutput(title = 'è¾“å‡ºç»“æœ') {
    const outputArea = document.getElementById('output-area');
    const outputTitle = document.getElementById('output-title');
    outputArea.classList.add('expanded');
    outputTitle.textContent = title;
  }

  // å…³é—­è¾“å‡ºåŒºåŸŸ
  function closeOutput() {
    const outputArea = document.getElementById('output-area');
    outputArea.classList.remove('expanded');
  }

  // æ˜¾ç¤ºJSONç»“æœ
  function showJsonResult(data, title = 'æ ¼å¼åŒ–ç»“æœ') {
    if (outputEditor) {
      const jsonStr = JSON.stringify(data, null, 2);
      outputEditor.setValue(jsonStr);
      expandOutput(title);
    } else {
      console.error('Output editor not initialized');
    }
  }

  function initializeJsonFormatter() {
    // åº”ç”¨æå–å‡½æ•°
    document.getElementById('apply-extract').addEventListener('click', () => {
      applyExtractFunction();
    });

    // æ¸…ç©ºæå–å‡½æ•°è¾“å…¥æ¡†
    document.getElementById('clear-extract-fn').addEventListener('click', () => {
      document.getElementById('extract-fn').value = '';
    });

    // æŒ‰é’®äº‹ä»¶ç»‘å®š
    document.getElementById('clear-btn').addEventListener('click', clearInputs);
    document.getElementById('collapse-all').addEventListener('click', collapseAll);
    document.getElementById('expand-all').addEventListener('click', expandAll);
    document.getElementById('remove-comments').addEventListener('click', removeComments);
    document.getElementById('compress-copy').addEventListener('click', () => compressAndCopy());
    document.getElementById('escape-copy').addEventListener('click', () => escapeAndCopy());
    document.getElementById('json-to-xml').addEventListener('click', () => jsonToXmlAndCopy());
    document.getElementById('json-to-ts').addEventListener('click', () => jsonToTsAndCopy());
    document.getElementById('json-to-csv').addEventListener('click', () => jsonToCsvAndCopy());
    document.getElementById('json-to-excel').addEventListener('click', () => jsonToExcelAndCopy());
    document.getElementById('json-to-yaml').addEventListener('click', () => jsonToYamlAndCopy());
    document.getElementById('json-to-html').addEventListener('click', () => jsonToHtmlAndCopy());
    document.getElementById('json-to-table').addEventListener('click', () => jsonToTable());
    document.getElementById('json-to-schema').addEventListener('click', () => jsonToSchema());
    document.getElementById('json-to-pdf').addEventListener('click', () => jsonToPdf());
    document.getElementById('json-to-dart').addEventListener('click', () => jsonToDartAndCopy());
    document.getElementById('json-to-c').addEventListener('click', () => jsonToCAndCopy());
    document.getElementById('json-to-go').addEventListener('click', () => jsonToGoAndCopy());
    document.getElementById('json-to-rust').addEventListener('click', () => jsonToRustAndCopy());
    document.getElementById('json-to-python').addEventListener('click', () => jsonToPythonAndCopy());
    document.getElementById('json-compare').addEventListener('click', () => toggleCompareMode());
    document.getElementById('close-output').addEventListener('click', closeOutput);
    document.getElementById('history-btn').addEventListener('click', showHistory);
    setupToolPriorityView();

    // å­—ä½“å¤§å°é€‰æ‹©å™¨
    const fontSizeSelect = document.getElementById('font-size-select');
    const savedFontSize = localStorage.getItem('editorFontSize') || '13';
    fontSizeSelect.value = savedFontSize;

    fontSizeSelect.addEventListener('change', (e) => {
      const fontSize = parseInt(e.target.value);
      if (editor) {
        editor.updateOptions({ fontSize: fontSize });
      }
      if (outputEditor) {
        outputEditor.updateOptions({ fontSize: fontSize });
      }
      localStorage.setItem('editorFontSize', fontSize);
    });
  }

  // é˜²æŠ–å‡½æ•°
  function setupToolPriorityView() {
    const controls = document.querySelector('.output-controls');
    if (!controls) return;

    const advancedIds = new Set([
      'escape-copy',
      'json-to-xml',
      'json-to-excel',
      'json-to-html',
      'json-to-pdf',
      'json-to-ts',
      'json-to-dart',
      'json-to-c',
      'json-to-go',
      'json-to-rust',
      'json-to-python',
      'json-to-schema',
      'json-to-table',
      'history-btn',
      'json-to-toon'
    ]);

    const advancedButtons = Array.from(controls.querySelectorAll('button')).filter((button) => advancedIds.has(button.id));
    if (advancedButtons.length === 0) return;

    const lang = (document.documentElement.lang || '').toLowerCase();
    const labels = lang.startsWith('zh')
      ? { more: 'æ›´å¤šå·¥å…·', less: 'æ”¶èµ·å·¥å…·' }
      : { more: 'More tools', less: 'Less tools' };

    const toggleBtn = document.createElement('button');
    toggleBtn.type = 'button';
    toggleBtn.id = 'toggle-advanced-tools';
    toggleBtn.setAttribute('aria-expanded', 'false');
    controls.appendChild(toggleBtn);

    const separators = Array.from(controls.querySelectorAll('.button-separator'));
    const storageKey = 'showAdvancedTools';
    let expanded = localStorage.getItem(storageKey) === 'true';

    const isVisibleControl = (node) => {
      if (!node || node.hidden) return false;
      if (node.tagName === 'BUTTON' || node.tagName === 'SELECT') return true;
      return false;
    };

    const updateSeparators = () => {
      separators.forEach((separator) => {
        let prev = separator.previousElementSibling;
        while (prev && prev.classList && prev.classList.contains('button-separator')) prev = prev.previousElementSibling;

        let next = separator.nextElementSibling;
        while (next && next.classList && next.classList.contains('button-separator')) next = next.nextElementSibling;

        separator.hidden = !(isVisibleControl(prev) && isVisibleControl(next));
      });
    };

    const applyState = () => {
      advancedButtons.forEach((button) => {
        button.hidden = !expanded;
      });
      toggleBtn.textContent = expanded ? labels.less : labels.more;
      toggleBtn.setAttribute('aria-expanded', String(expanded));
      localStorage.setItem(storageKey, String(expanded));
      updateSeparators();
    };

    toggleBtn.addEventListener('click', () => {
      expanded = !expanded;
      applyState();
    });

    applyState();
  }
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // æ ¼å¼åŒ–è¾“å…¥å‡½æ•°å·²ç§»é™¤ï¼Œä½¿ç”¨è‡ªåŠ¨æ ¼å¼åŒ–æ›¿ä»£

  // è§£æJSON
  function parseJson(str) {
    if (!str.trim()) return {};
    return JSON.parse(str);
  }

  // åº”ç”¨æå–å‡½æ•°
  async function applyExtractFunction() {
    const extractFnStr = document.getElementById('extract-fn').value.trim();

    if (!extractFnStr) {
      showToast(translations.enterExtractionFn || 'Please enter an extraction function');
      return;
    }

    try {
      const inputText = getEditorContent();
      if (!inputText.trim()) {
        showToast(translations.enterData || 'Please enter data to process');
        return;
      }

      const parsedData = parseJson(inputText);
      const fn = new Function('obj', `return (${extractFnStr})(obj);`);
      const result = fn(parsedData);

      // åªæœ‰åœ¨åº”ç”¨æå–å‡½æ•°åæ‰æ˜¾ç¤ºè¾“å‡ºæ¡†
      showJsonResult(result, 'Extraction Result');
    } catch (error) {
      showToast((translations.extractionError || 'Extraction error') + ': ' + error.message);
    }
  }

  // æ¸…ç©ºè¾“å…¥
  function clearInputs() {
    setEditorContent('');
    document.getElementById('extract-fn').value = '';
    if (outputEditor) {
      outputEditor.setValue('');
    }
    closeOutput();

    // é‡æ–°æ˜¾ç¤ºæç¤º
    const hint = document.getElementById('editor-hint');
    if (hint) {
      hint.classList.remove('hint-hidden');
    }
  }

  // æŠ˜å æ‰€æœ‰
  function collapseAll() {
    // æŠ˜å è¾“å…¥ç¼–è¾‘å™¨
    if (editor) {
      editor.getAction('editor.foldAll').run();
    }

    // æŠ˜å è¾“å‡ºç¼–è¾‘å™¨
    if (outputEditor) {
      outputEditor.getAction('editor.foldAll').run();
    }
  }

  // å±•å¼€æ‰€æœ‰
  function expandAll() {
    // å±•å¼€è¾“å…¥ç¼–è¾‘å™¨
    if (editor) {
      editor.getAction('editor.unfoldAll').run();
    }

    // å±•å¼€è¾“å‡ºç¼–è¾‘å™¨
    if (outputEditor) {
      outputEditor.getAction('editor.unfoldAll').run();
    }
  }

  // å»é™¤æ³¨é‡Š
  function removeComments() {
    let value = getEditorContent();
    value = value.replace(/\/\*[\s\S]*?\*\//g, '');
    value = value.replace(/\/\/.*/g, '');
    setEditorContent(value);
    // è§¦å‘è‡ªåŠ¨æ ¼å¼åŒ–
    autoFormatJson();
  }

  // å‹ç¼©å¹¶å¤åˆ¶
  async function compressAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const compressed = JSON.stringify(parsedData);
      await navigator.clipboard.writeText(compressed);
      showToast(translations.compressSuccess || 'Compressed JSON copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // è½¬ä¹‰å¹¶å¤åˆ¶
  async function escapeAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const compressed = JSON.stringify(parsedData);
      const escaped = compressed.replace(/[\\]/g, '\\\\').replace(/["]/g, '\\"');
      await navigator.clipboard.writeText(escaped);
      showToast(translations.escapeSuccess || 'Escaped JSON copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // JSONè½¬XMLå¹¶å¤åˆ¶
  async function jsonToXmlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const xmlString = jsonToXml(parsedData, 'root');
      await navigator.clipboard.writeText(xmlString);
      showToast(translations.xmlSuccess || 'XML copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // JSONè½¬TypeScriptå¹¶å¤åˆ¶
  async function jsonToTsAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const tsInterface = jsonToTsInterface(parsedData, 'DataType');
      await navigator.clipboard.writeText(tsInterface);
      showToast(translations.tsSuccess || 'TypeScript interface copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // JSONè½¬CSVå¹¶å¤åˆ¶
  async function jsonToCsvAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const csvString = jsonToCsv(parsedData);
      await navigator.clipboard.writeText(csvString);
      showToast(translations.csvSuccess || 'CSV copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // JSONè½¬Excelå¹¶å¤åˆ¶ï¼ˆå®é™…ç”ŸæˆCSVæ ¼å¼ï¼Œå¯ç›´æ¥å¯¼å…¥Excelï¼‰
  async function jsonToExcelAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const csvString = jsonToCsv(parsedData);
      await navigator.clipboard.writeText(csvString);
      showToast(translations.excelSuccess || 'Excel data copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // ========== æ–¹æ¡ˆ1: JSON to YAML ==========
  async function jsonToYamlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const yamlString = jsonToYaml(parsedData);
      await navigator.clipboard.writeText(yamlString);
      showToast(translations.yamlSuccess || 'YAML copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToYaml(obj, indent = 0) {
    const spaces = '  '.repeat(indent);

    if (obj === null || obj === undefined) {
      return 'null';
    }

    if (typeof obj !== 'object') {
      return String(obj);
    }

    if (Array.isArray(obj)) {
      if (obj.length === 0) return '[]';
      return obj.map(item => {
        if (typeof item === 'object' && item !== null) {
          return '-\n' + jsonToYaml(item, indent + 1).split('\n').map(line => spaces + line).join('\n').substring(2);
        } else {
          return '- ' + jsonToYaml(item, 0);
        }
      }).join('\n' + spaces);
    }

    // Object
    const entries = Object.entries(obj);
    if (entries.length === 0) return '{}';

    return entries.map(([key, value]) => {
      if (value === null) {
        return `${key}: null`;
      } else if (typeof value === 'object' && value !== null) {
        return `${key}:\n${jsonToYaml(value, indent + 1).split('\n').map(line => spaces + line).join('\n')}`;
      } else if (typeof value === 'string') {
        return `${key}: "${value}"`;
      } else {
        return `${key}: ${value}`;
      }
    }).join('\n' + spaces);
  }

  // ========== æ–¹æ¡ˆ1: JSON to Table ==========
  async function jsonToTable() {
    try {
      // å…ˆé‡ç½®ç•Œé¢åˆ°é»˜è®¤çŠ¶æ€ï¼Œæ¸…é™¤å…¶ä»–åŠŸèƒ½çš„æ˜¾ç¤º
      resetViewToDefault();

      const parsedData = parseJson(getEditorContent());
      const tableHtml = jsonToTableHtml(parsedData);

      // åœ¨è¾“å‡ºåŒºåŸŸæ˜¾ç¤ºè¡¨æ ¼
      if (outputEditor) {
        const outputArea = document.getElementById('output-area');
        const outputContent = document.getElementById('output-content');

        // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å®¹å™¨æ¥æ˜¾ç¤ºHTML
        const tempDiv = document.createElement('div');
        tempDiv.className = 'table-output';
        tempDiv.innerHTML = `
          <div style="padding: 20px; overflow: auto;">
            ${tableHtml}
          </div>
        `;

        // éšè—ç¼–è¾‘å™¨ï¼Œæ˜¾ç¤ºè¡¨æ ¼
        outputContent.querySelector('.monaco-editor-container')?.style.setProperty('display', 'none');
        const existingTable = outputContent.querySelector('.table-output');
        if (existingTable) {
          existingTable.remove();
        }
        outputContent.appendChild(tempDiv);

        expandOutput('JSON Table');
      }
      showToast(translations.tableSuccess || 'Table generated successfully!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToTableHtml(obj) {
    if (!obj || typeof obj !== 'object') {
      return '<p>Input is not a valid JSON object</p>';
    }

    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return '<p>Empty array</p>';
      }

      // è·å–æ‰€æœ‰å¯èƒ½çš„é”®
      const allKeys = [...new Set(obj.flatMap(item => Object.keys(item || {})))];

      if (allKeys.length === 0) {
        return '<table class="json-table"><tbody><tr><td>Array with ' + obj.length + ' items (no properties)</td></tr></tbody></table>';
      }

      let html = '<table class="json-table"><thead><tr>';
      allKeys.forEach(key => {
        html += `<th>${escapeHtml(key)}</th>`;
      });
      html += '</tr></thead><tbody>';

      obj.forEach(item => {
        html += '<tr>';
        allKeys.forEach(key => {
          const value = item && item[key];
          html += `<td>${formatValueForTable(value)}</td>`;
        });
        html += '</tr>';
      });

      html += '</tbody></table>';
      return html;
    }

    // å¯¹è±¡è½¬ä¸ºè¡¨æ ¼
    const entries = Object.entries(obj);
    let html = '<table class="json-table"><tbody>';
    entries.forEach(([key, value]) => {
      html += '<tr>';
      html += `<td class="key-column"><strong>${escapeHtml(key)}</strong></td>`;
      html += `<td>${formatValueForTable(value)}</td>`;
      html += '</tr>';
    });
    html += '</tbody></table>';
    return html;
  }

  function formatValueForTable(value) {
    if (value === null || value === undefined) {
      return '<em>null</em>';
    }
    if (typeof value === 'object') {
      return `<code class="inline-code">${escapeHtml(JSON.stringify(value))}</code>`;
    }
    if (typeof value === 'boolean') {
      return `<span class="boolean-${value}">${value}</span>`;
    }
    if (typeof value === 'number') {
      return `<span class="number">${value}</span>`;
    }
    return escapeHtml(String(value));
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // ========== æ–¹æ¡ˆ1: JSON Schema ==========
  async function jsonToSchema() {
    try {
      // å…ˆé‡ç½®ç•Œé¢åˆ°é»˜è®¤çŠ¶æ€ï¼Œæ¸…é™¤å…¶ä»–åŠŸèƒ½çš„æ˜¾ç¤º
      resetViewToDefault();

      const parsedData = parseJson(getEditorContent());
      const schema = generateJsonSchema(parsedData, 'RootObject');

      // æ˜¾ç¤ºschema
      if (outputEditor) {
        const schemaStr = JSON.stringify(schema, null, 2);
        outputEditor.setValue(schemaStr);
        expandOutput('JSON Schema');
      }
      showToast(translations.schemaSuccess || 'JSON Schema generated successfully!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function generateJsonSchema(obj, typeName = 'Object') {
    if (obj === null || obj === undefined) {
      return { type: 'null' };
    }

    if (typeof obj === 'string') {
      return { type: 'string' };
    }

    if (typeof obj === 'number') {
      return { type: 'number' };
    }

    if (typeof obj === 'boolean') {
      return { type: 'boolean' };
    }

    if (Array.isArray(obj)) {
      if (obj.length > 0) {
        return {
          type: 'array',
          items: generateJsonSchema(obj[0])
        };
      }
      return {
        type: 'array',
        items: {}
      };
    }

    // Object
    const properties = {};
    const required = [];

    for (const [key, value] of Object.entries(obj)) {
      properties[key] = generateJsonSchema(value);
      required.push(key);
    }

    return {
      type: 'object',
      properties,
      required
    };
  }

  // ========== æ–¹æ¡ˆ2: JSON to HTML ==========
  async function jsonToHtmlAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const htmlString = jsonToHtml(parsedData);
      await navigator.clipboard.writeText(htmlString);
      showToast(translations.htmlSuccess || 'HTML copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToHtml(obj, indent = 0) {
    const spaces = '  '.repeat(indent);

    if (obj === null || obj === undefined) {
      return `${spaces}<span class="json-null">null</span>\n`;
    }

    if (typeof obj !== 'object') {
      const formatted = typeof obj === 'string' ? `"${obj}"` : String(obj);
      return `${spaces}<span class="json-value">${escapeHtml(formatted)}</span>\n`;
    }

    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return `${spaces}<span class="json-bracket">[]</span>\n`;
      }

      let html = `${spaces}<span class="json-bracket">[</span>\n`;
      obj.forEach((item, index) => {
        html += jsonToHtml(item, indent + 1);
        if (index < obj.length - 1) {
          html = html.trimEnd() + ',\n';
        }
      });
      html += `${spaces}<span class="json-bracket">]</span>\n`;
      return html;
    }

    // Object
    const entries = Object.entries(obj);
    if (entries.length === 0) {
      return `${spaces}<span class="json-bracket">{}</span>\n`;
    }

    let html = `${spaces}<div class="json-object">\n`;
    html += `${spaces}<span class="json-bracket">{</span>\n`;
    entries.forEach(([key, value], index) => {
      html += `${spaces}  <span class="json-key">"${escapeHtml(key)}"</span>: `;
      if (typeof value === 'object' && value !== null) {
        html += '\n' + jsonToHtml(value, indent + 2);
      } else {
        html += jsonToHtml(value, 0).trim();
      }
      if (index < entries.length - 1) {
        html += ',';
      }
      html += '\n';
    });
    html += `${spaces}<span class="json-bracket">}</span>\n`;
    html += `${spaces}</div>\n`;
    return html;
  }

  // ========== æ–¹æ¡ˆ2: JSON to PDF ==========
  async function jsonToPdf() {
    try {
      const parsedData = parseJson(getEditorContent());

      // ä½¿ç”¨html2pdf.jsæˆ–jsPDFç”ŸæˆPDF
      // è¿™é‡Œä½¿ç”¨ç®€å•çš„HTMLæ‰“å°æ–¹æ¡ˆ
      const jsonStr = JSON.stringify(parsedData, null, 2);
      const htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>JSON Export</title>
          <style>
            body { font-family: monospace; white-space: pre-wrap; padding: 20px; }
            @media print {
              body { padding: 0; }
            }
          </style>
        </head>
        <body>${escapeHtml(jsonStr)}</body>
        </html>
      `;

      // åˆ›å»ºæ–°çª—å£å¹¶æ‰“å°
      const printWindow = window.open('', '_blank');
      printWindow.document.write(htmlContent);
      printWindow.document.close();
      printWindow.focus();

      setTimeout(() => {
        printWindow.print();
      }, 250);

      showToast(translations.pdfSuccess || 'PDF export initiated!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  // ========== æ–¹æ¡ˆ3: JSON to Dart ==========
  async function jsonToDartAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const dartCode = jsonToDart(parsedData, 'JsonObject');
      await navigator.clipboard.writeText(dartCode);
      showToast(translations.dartSuccess || 'Dart code copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToDart(obj, className = 'JsonObject') {
    if (Array.isArray(obj)) {
      if (obj.length > 0) {
        const itemClass = `${className}Item`;
        return `List<${itemClass}> ${camelCase(className)} = [${obj.map(() => `${itemClass}()`).join(', ')}];\n\n${jsonToDart(obj[0], itemClass)}`;
      }
      return `List<dynamic> ${camelCase(className)} = [];`;
    }

    if (typeof obj !== 'object' || obj === null) {
      return `final ${camelCase(className)} = ${obj === null ? 'null' : JSON.stringify(obj)};`;
    }

    let code = `class ${className} {\n`;

    // Fields
    for (const [key, value] of Object.entries(obj)) {
      const dartType = getDartType(value);
      const fieldName = camelCase(key);
      code += `  ${dartType} ${fieldName};\n`;
    }

    code += '\n';

    // Constructor
    code += `  ${className}({\n`;
    for (const [key] of Object.entries(obj)) {
      const fieldName = camelCase(key);
      code += `    this.${fieldName},\n`;
    }
    code += `  });\n\n`;

    // fromJson factory
    code += `  factory ${className}.fromJson(Map<String, dynamic> json) {\n`;
    code += `    return ${className}(\n`;
    for (const [key, value] of Object.entries(obj)) {
      const fieldName = camelCase(key);
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        code += `      ${fieldName}: ${fieldName}Class.fromJson(json['${key}']),\n`;
      } else {
        code += `      ${fieldName}: json['${key}'],\n`;
      }
    }
    code += `    );\n`;
    code += `  }\n\n`;

    // toJson method
    code += `  Map<String, dynamic> toJson() {\n`;
    code += `    return {\n`;
    for (const [key] of Object.entries(obj)) {
      const fieldName = camelCase(key);
      code += `      '${key}': this.${fieldName},\n`;
    }
    code += `    };\n`;
    code += `  }\n`;

    code += `}\n`;

    return code;
  }

  function getDartType(value) {
    if (value === null) return 'dynamic';
    if (typeof value === 'string') return 'String';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'double';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'List<dynamic>';
    return 'Map<String, dynamic>';
  }

  // ========== æ–¹æ¡ˆ3: JSON to C ==========
  async function jsonToCAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const cCode = jsonToC(parsedData, 'JsonObject');
      await navigator.clipboard.writeText(cCode);
      showToast(translations.cSuccess || 'C code copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToC(obj, structName = 'JsonObject') {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return `// Cannot generate C struct for ${typeof obj}`;
    }

    let code = `typedef struct {\n`;

    for (const [key, value] of Object.entries(obj)) {
      const cType = getCType(value);
      const fieldName = camelCase(key);
      code += `  ${cType} ${fieldName};\n`;
    }

    code += `} ${structName};\n`;

    return code;
  }

  function getCType(value) {
    if (value === null) return 'void*';
    if (typeof value === 'string') return 'char*';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'double';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'void**';
    return 'void*';
  }

  // ========== æ–¹æ¡ˆ3: JSON to Go ==========
  async function jsonToGoAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const goCode = jsonToGo(parsedData, 'JsonObject');
      await navigator.clipboard.writeText(goCode);
      showToast(translations.goSuccess || 'Go code copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToGo(obj, structName = 'JsonObject') {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return `// Cannot generate Go struct for ${typeof obj}`;
    }

    let code = `type ${structName} struct {\n`;

    for (const [key, value] of Object.entries(obj)) {
      const goType = getGoType(value);
      const fieldName = pascalCase(key);
      code += `  ${fieldName} ${goType} \`json:"${key}"\`\n`;
    }

    code += `}\n`;

    return code;
  }

  function getGoType(value) {
    if (value === null) return 'interface{}';
    if (typeof value === 'string') return 'string';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float64';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return '[]interface{}';
    return 'map[string]interface{}';
  }

  function pascalCase(str) {
    return str.replace(/(\w)(\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase()).replace(/[^a-zA-Z0-9]/g, '');
  }

  // ========== æ–¹æ¡ˆ3: JSON to Rust ==========
  async function jsonToRustAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const rustCode = jsonToRust(parsedData, 'JsonObject');
      await navigator.clipboard.writeText(rustCode);
      showToast(translations.rustSuccess || 'Rust code copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToRust(obj, structName = 'JsonObject') {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return `// Cannot generate Rust struct for ${typeof obj}`;
    }

    let code = `#[derive(Serialize, Deserialize)]\n`;
    code += `struct ${structName} {\n`;

    for (const [key, value] of Object.entries(obj)) {
      const rustType = getRustType(value);
      const fieldName = snakeCase(key);
      code += `  #[serde(rename = "${key}")]\n`;
      code += `  ${fieldName}: ${rustType},\n`;
    }

    code += `}\n`;

    return code;
  }

  function getRustType(value) {
    if (value === null) return 'Option<Value>';
    if (typeof value === 'string') return 'String';
    if (typeof value === 'number') return Number.isInteger(value) ? 'i64' : 'f64';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'Vec<Value>';
    return 'Value';
  }

  function snakeCase(str) {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '').replace(/[^a-zA-Z0-9]/g, '_');
  }

  // ========== æ–¹æ¡ˆ3: JSON to Python ==========
  async function jsonToPythonAndCopy() {
    try {
      const parsedData = parseJson(getEditorContent());
      const pythonCode = jsonToPython(parsedData, 'JsonObject');
      await navigator.clipboard.writeText(pythonCode);
      showToast(translations.pythonSuccess || 'Python code copied to clipboard!');
    } catch (error) {
      showToast((translations.parsingError || 'Error') + ': ' + error.message);
    }
  }

  function jsonToPython(obj, className = 'JsonObject') {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return `# Cannot generate Python class for ${typeof obj}`;
    }

    let code = `from dataclasses import dataclass\nfrom typing import Optional, List, Any\n\n`;
    code += `@dataclass\nclass ${className}:\n`;

    for (const [key, value] of Object.entries(obj)) {
      const pythonType = getPythonType(value);
      const fieldName = snakeCase(key);
      code += `  ${fieldName}: ${pythonType}\n`;
    }

    return code;
  }

  function getPythonType(value) {
    if (value === null) return 'Optional[Any]';
    if (typeof value === 'string') return 'str';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) return 'List[Any]';
    return 'dict';
  }

  // é€šç”¨å·¥å…·å‡½æ•°
  function camelCase(str) {
    return str.replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');
  }

  // JSONè½¬XMLè¾…åŠ©å‡½æ•°
  function jsonToXml(obj, tagName) {
    if (obj === null || obj === undefined) {
      return `<${tagName}></${tagName}>`;
    }

    if (typeof obj !== 'object') {
      return `<${tagName}>${obj}</${tagName}>`;
    }

    if (Array.isArray(obj)) {
      return obj.map(item => jsonToXml(item, tagName)).join('');
    }

    let xml = `<${tagName}>`;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (typeof value === 'object') {
          xml += jsonToXml(value, key);
        } else {
          xml += `<${key}>${value}</${key}>`;
        }
      }
    }
    xml += `</${tagName}>`;

    return xml;
  }

  // JSONè½¬CSVè¾…åŠ©å‡½æ•°
  function jsonToCsv(obj) {
    // å¤„ç†ç©ºå€¼
    if (obj === null || obj === undefined) {
      throw new Error('Input data cannot be empty');
    }

    // ç¡®ä¿è¾“å…¥æ˜¯æ•°ç»„ï¼Œå¦‚æœæ˜¯å•ä¸ªå¯¹è±¡åˆ™è½¬æ¢ä¸ºæ•°ç»„
    const jsonArray = Array.isArray(obj) ? obj : [obj];

    // å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
    if (jsonArray.length === 0) {
      throw new Error('Input array cannot be empty');
    }

    // è·å–æ‰€æœ‰å”¯ä¸€çš„é”®ä½œä¸ºCSVæ ‡é¢˜ï¼ˆä½¿ç”¨Mapä¿æŒæ’å…¥é¡ºåºï¼‰
    const headersMap = new Map();
    let hasValidData = false;
    jsonArray.forEach(item => {
      if (typeof item === 'object' && item !== null) {
        const keys = Object.keys(item);
        if (keys.length > 0) {
          hasValidData = true;
          keys.forEach(key => headersMap.set(key, true));
        }
      }
    });

    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼ŒæŠ›å‡ºé”™è¯¯
    if (!hasValidData) {
      throw new Error('No valid data to convert');
    }

    // å°†Mapçš„é”®è½¬æ¢ä¸ºæ•°ç»„ï¼ˆä¿æŒé¡ºåºï¼‰
    const headerArray = Array.from(headersMap.keys());

    // è¾…åŠ©å‡½æ•°ï¼šå°†ä»»æ„å€¼è½¬æ¢ä¸ºCSVå­—ç¬¦ä¸²
    function valueToCsvString(value) {
      // å¤„ç†nullå’Œundefined
      if (value === null || value === undefined) {
        return '';
      }

      // å¤„ç†å¯¹è±¡å’Œæ•°ç»„ï¼ˆè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²ï¼‰
      if (typeof value === 'object') {
        value = JSON.stringify(value);
      }

      // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
      let str = String(value);

      // è½¬ä¹‰å¼•å·ï¼ˆå°†"å˜æˆ""ï¼‰
      str = str.replace(/"/g, '""');

      // å¦‚æœåŒ…å«é€—å·ã€å¼•å·ã€æ¢è¡Œç¬¦ï¼Œç”¨å¼•å·åŒ…è£¹
      if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        str = `"${str}"`;
      }

      return str;
    }

    // ç”ŸæˆCSVå†…å®¹
    let csv = headerArray.join(',') + '\n';

    // éå†æ•°ç»„ç”ŸæˆCSVè¡Œ
    jsonArray.forEach(item => {
      const row = headerArray.map(header => {
        const value = item[header];
        return valueToCsvString(value);
      });
      csv += row.join(',') + '\n';
    });

    return csv;
  }

  // JSONè½¬TypeScriptæ¥å£è¾…åŠ©å‡½æ•°
  function jsonToTsInterface(obj, interfaceName) {
    if (typeof obj !== 'object' || obj === null) {
      return `// Cannot generate interface from non-object type`;
    }

    // If it's an array, use the first element to generate the interface
    let targetObj = obj;
    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return `// Cannot generate interface from empty array`;
      }
      // Use the first element of the array to generate the interface
      targetObj = obj[0];
      // If the first element is not an object, return error message
      if (typeof targetObj !== 'object' || targetObj === null) {
        return `// Cannot generate interface from non-object type`;
      }
    }

    let ts = `interface ${interfaceName} {\n`;

    for (const key in targetObj) {
      if (targetObj.hasOwnProperty(key)) {
        const value = targetObj[key];
        let type;

        if (value === null) {
          type = 'any';
        } else if (Array.isArray(value)) {
          if (value.length > 0) {
            const elementType = typeof value[0];
            if (elementType === 'object' && value[0] !== null) {
              // If array elements are objects, generate nested interface
              const nestedInterfaceName = `${key.charAt(0).toUpperCase() + key.slice(1)}Item`;
              type = `${nestedInterfaceName}[]`;
              ts += jsonToTsInterface(value[0], nestedInterfaceName);
            } else {
              // Otherwise use basic type
              type = `${getType(elementType)}[]`;
            }
          } else {
            type = 'any[]';
          }
        } else if (typeof value === 'object') {
          type = `${key.charAt(0).toUpperCase() + key.slice(1)}Type`;
          ts += jsonToTsInterface(value, type);
        } else {
          type = getType(typeof value);
        }

        ts += `  ${key}: ${type};\n`;
      }
    }

    ts += `}\n`;
    
    // If original input was an array, generate array type export
    if (Array.isArray(obj)) {
      ts += `\nexport type ${interfaceName}Array = ${interfaceName}[];\n`;
    }
    
    return ts;
  }

  // è·å–ç±»å‹å­—ç¬¦ä¸²
  function getType(jsType) {
    switch(jsType) {
      case 'string': return 'string';
      case 'number': return 'number';
      case 'boolean': return 'boolean';
      case 'object': return 'object';
      default: return 'any';
    }
  }

  // æœ¬åœ°å­˜å‚¨ç›¸å…³å‡½æ•°
  const HISTORY_KEY = 'json-formatter-history';
  const MAX_HISTORY_ITEMS = 50;

  // ä¿å­˜å†å²è®°å½•
  function saveToHistory(data) {
    try {
      const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
      
      // ç§»é™¤é‡å¤é¡¹
      const filteredHistory = history.filter(item => item.data !== data);
      
      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
      filteredHistory.unshift({
        id: Date.now(),
        data: data,
        timestamp: new Date().toISOString()
      });
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      const limitedHistory = filteredHistory.slice(0, MAX_HISTORY_ITEMS);
      
      localStorage.setItem(HISTORY_KEY, JSON.stringify(limitedHistory));
    } catch (error) {
      console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', error);
    }
  }

  // è·å–å†å²è®°å½•
  function getHistory() {
    try {
      return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
    } catch (error) {
      console.error('è·å–å†å²è®°å½•å¤±è´¥:', error);
      return [];
    }
  }

  // æ¸…é™¤å†å²è®°å½•
  function clearHistory() {
    try {
      localStorage.removeItem(HISTORY_KEY);
    } catch (error) {
      console.error('æ¸…é™¤å†å²è®°å½•å¤±è´¥:', error);
    }
  }

  // æ˜¾ç¤ºå†å²è®°å½•
  function showHistory() {
    const history = getHistory();

    if (history.length === 0) {
      showToast(translations.noHistory || 'No history records');
      return;
    }
    
    // åˆ›å»ºé®ç½©å±‚
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
    `;
    
    // åˆ›å»ºå†å²è®°å½•å¼¹çª—
    const historyContainer = document.createElement('div');
    historyContainer.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      width: 90%;
      max-width: 1200px;
      max-height: 90%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    `;
    
    // åˆ›å»ºæ ‡é¢˜è¡Œ
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    `;
    
    // åˆ›å»ºæ ‡é¢˜
    const title = document.createElement('h3');
    title.textContent = 'History';
    title.style.cssText = `
      margin: 0;
      font-size: 18px;
    `;
    header.appendChild(title);
    
    // åˆ›å»ºå…³é—­æŒ‰é’®
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background-color 0.2s;
    `;
    
    closeBtn.onmouseenter = () => {
      closeBtn.style.backgroundColor = '#f5f5f5';
    };
    
    closeBtn.onmouseleave = () => {
      closeBtn.style.backgroundColor = 'transparent';
    };
    
    closeBtn.onclick = () => {
      document.body.removeChild(overlay);
      document.body.removeChild(historyContainer);
    };
    
    header.appendChild(closeBtn);
    historyContainer.appendChild(header);
    
    // åˆ›å»ºæœç´¢æ¡†
    const searchContainer = document.createElement('div');
    searchContainer.style.cssText = `
      margin-bottom: 15px;
    `;
    
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.placeholder = 'æœç´¢å†å²è®°å½•...';
    searchInput.style.cssText = `
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    `;
    
    searchContainer.appendChild(searchInput);
    historyContainer.appendChild(searchContainer);
    
    // åˆ›å»ºæ¸…é™¤å†å²è®°å½•æŒ‰é’®
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'æ¸…é™¤æ‰€æœ‰å†å²è®°å½•';
    clearBtn.style.cssText = `
      margin-bottom: 15px;
      padding: 8px 16px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    `;
    
    clearBtn.onmouseenter = () => {
      clearBtn.style.backgroundColor = '#dc2626';
    };
    
    clearBtn.onmouseleave = () => {
      clearBtn.style.backgroundColor = '#ef4444';
    };
    
    clearBtn.onclick = () => {
      if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ')) {
        clearHistory();
        document.body.removeChild(overlay);
        document.body.removeChild(historyContainer);
        showToast('å†å²è®°å½•å·²æ¸…é™¤');
      }
    };
    
    historyContainer.appendChild(clearBtn);
    
    // åˆ›å»ºè¡¨æ ¼å®¹å™¨
    const tableContainer = document.createElement('div');
    tableContainer.style.cssText = `
      flex: 1;
      overflow: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    `;
    
    // åˆ›å»ºè¡¨æ ¼
    const table = document.createElement('table');
    table.style.cssText = `
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    `;
    
    // åˆ›å»ºè¡¨å¤´
    const thead = document.createElement('thead');
    thead.style.cssText = `
      background-color: #f9fafb;
      position: sticky;
      top: 0;
      z-index: 10;
    `;
    
    const headerRow = document.createElement('tr');
    const headers = ['åºå·', 'æ—¶é—´', 'JSONæ•°æ®', 'æ“ä½œ'];
    const headerWidths = ['60px', '150px', 'auto', '120px'];
    
    headers.forEach((headerText, index) => {
      const th = document.createElement('th');
      th.textContent = headerText;
      th.style.cssText = `
        padding: 10px 8px;
        text-align: left;
        border-bottom: 2px solid #ddd;
        font-weight: 600;
        width: ${headerWidths[index]};
      `;
      headerRow.appendChild(th);
    });
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // åˆ›å»ºè¡¨ä½“
    const tbody = document.createElement('tbody');
    
    // æ·»åŠ è®°å½•åˆ°è¡¨æ ¼çš„å‡½æ•°
    function addRecordsToTable(records) {
      tbody.innerHTML = '';
      
      records.forEach((item, index) => {
        const tr = document.createElement('tr');
        tr.style.cssText = `
          border-bottom: 1px solid #eee;
          transition: background-color 0.2s;
        `;
        
        tr.onmouseenter = () => {
          tr.style.backgroundColor = '#f5f5f5';
        };
        
        tr.onmouseleave = () => {
          tr.style.backgroundColor = 'transparent';
        };
        
        // åºå·åˆ—
        const indexTd = document.createElement('td');
        indexTd.textContent = index + 1;
        indexTd.style.cssText = `
          padding: 8px;
          text-align: center;
          font-weight: 500;
        `;
        tr.appendChild(indexTd);
        
        // æ—¶é—´åˆ—
        const timeTd = document.createElement('td');
        timeTd.textContent = new Date(item.timestamp).toLocaleString();
        timeTd.style.cssText = `
          padding: 8px;
          color: #666;
        `;
        tr.appendChild(timeTd);
        
        // JSONæ•°æ®åˆ—
        const dataTd = document.createElement('td');
        dataTd.style.cssText = `
          padding: 8px;
          max-width: 500px;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          font-size: 12px;
          cursor: pointer;
          color: #2563eb;
        `;
        
        const jsonPreview = item.data.substring(0, 150) + (item.data.length > 150 ? '...' : '');
        dataTd.textContent = jsonPreview;
        dataTd.title = 'ç‚¹å‡»å¤åˆ¶å®Œæ•´JSON';
        
        // ç‚¹å‡»JSONæ•°æ®å¤åˆ¶åˆ°å‰ªè´´æ¿
        dataTd.onclick = (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(item.data).then(() => {
            showToast('JSONå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
          }).catch(err => {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
          });
        };
        
        tr.appendChild(dataTd);
        
        // æ“ä½œåˆ—
        const actionTd = document.createElement('td');
        actionTd.style.cssText = `
          padding: 8px;
          display: flex;
          gap: 6px;
          justify-content: center;
        `;
        
        // å¤åˆ¶æŒ‰é’®
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'å¤åˆ¶';
        copyBtn.style.cssText = `
          padding: 4px 8px;
          background: #3b82f6;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          transition: background-color 0.2s;
        `;
        
        copyBtn.onmouseenter = () => {
          copyBtn.style.backgroundColor = '#2563eb';
        };
        
        copyBtn.onmouseleave = () => {
          copyBtn.style.backgroundColor = '#3b82f6';
        };
        
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(item.data).then(() => {
            showToast('JSONå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
          }).catch(err => {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
          });
        };
        
        actionTd.appendChild(copyBtn);
        
        // åˆ é™¤æŒ‰é’®
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.style.cssText = `
          padding: 4px 8px;
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          transition: background-color 0.2s;
        `;
        
        deleteBtn.onmouseenter = () => {
          deleteBtn.style.backgroundColor = '#dc2626';
        };
        
        deleteBtn.onmouseleave = () => {
          deleteBtn.style.backgroundColor = '#ef4444';
        };
        
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          if (confirm(translations.deleteConfirm || 'Are you sure you want to delete this record?')) {
            const updatedHistory = history.filter(h => h.id !== item.id);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(updatedHistory));
            // æ›´æ–°è¡¨æ ¼
            const filteredHistory = searchInput.value
              ? updatedHistory.filter(h => h.data.includes(searchInput.value))
              : updatedHistory;
            addRecordsToTable(filteredHistory);
            showToast(translations.recordDeleted || 'Record deleted');
          }
        };
        
        actionTd.appendChild(deleteBtn);
        tr.appendChild(actionTd);
        
        // ç‚¹å‡»æ•´è¡Œæ¢å¤æ•°æ®
        tr.onclick = () => {
          setEditorContent(item.data);
          autoFormatJson();
          document.body.removeChild(overlay);
          document.body.removeChild(historyContainer);
        };
        
        tbody.appendChild(tr);
      });
    }
    
    // åˆå§‹åŠ è½½æ‰€æœ‰è®°å½•
    addRecordsToTable(history);
    
    table.appendChild(tbody);
    tableContainer.appendChild(table);
    historyContainer.appendChild(tableContainer);
    
    // æ·»åŠ æœç´¢åŠŸèƒ½
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      const filteredHistory = history.filter(item => 
        item.data.toLowerCase().includes(searchTerm)
      );
      addRecordsToTable(filteredHistory);
    });
    
    // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
    overlay.onclick = () => {
      document.body.removeChild(overlay);
      document.body.removeChild(historyContainer);
    };
    
    // æ·»åŠ åˆ°é¡µé¢
    document.body.appendChild(overlay);
    document.body.appendChild(historyContainer);
  }

  // ç»Ÿä¸€çš„ç•Œé¢é‡ç½®å‡½æ•° - ç¡®ä¿æ¯æ¬¡åªæ˜¾ç¤ºä¸€ä¸ªåŠŸèƒ½
  function resetViewToDefault() {
    // å¦‚æœåœ¨æ¯”è¾ƒæ¨¡å¼ï¼Œå…ˆé€€å‡º
    if (isCompareMode) {
      const compareSection = document.getElementById('compare-section');
      const editorsWrapper = document.getElementById('editors-wrapper');
      const firstSection = document.querySelector('.input-section');

      isCompareMode = false;
      compareSection.classList.add('hidden');
      editorsWrapper.classList.remove('compare-mode');

      // æ¢å¤ç¼–è¾‘å™¨æ ‡é¢˜
      const firstLabel = firstSection.querySelector('.section-label');
      if (firstLabel) {
        firstLabel.textContent = translations.sectionLabel || 'JSON å·¥å…· - æ ¼å¼åŒ–ã€è½¬æ¢ä¸º ISONï¼ˆèŠ‚çœ 70% Tokenï¼‰ã€CSV ç­‰';
      }

      // æ¸…é™¤é«˜äº®
      clearHighlightDecorations();

      // æ¸…ç©ºæ¯”è¾ƒç¼–è¾‘å™¨
      if (compareEditor) {
        compareEditor.setValue('');
      }
    }

    // æ¸…ç©ºæ‰€æœ‰å¯èƒ½çš„è¾“å‡ºå†…å®¹
    const outputContent = document.getElementById('output-content');
    if (outputContent) {
      // ç§»é™¤æ‰€æœ‰ç‰¹æ®Šè¾“å‡ºï¼ˆè¡¨æ ¼ã€HTMLç­‰ï¼‰
      const tableOutput = outputContent.querySelector('.table-output');
      const htmlOutput = outputContent.querySelector('.html-output');
      const schemaOutput = outputContent.querySelector('.schema-output');

      if (tableOutput) tableOutput.remove();
      if (htmlOutput) htmlOutput.remove();
      if (schemaOutput) schemaOutput.remove();

      // æ¢å¤ç¼–è¾‘å™¨æ˜¾ç¤º
      const editorContainer = outputContent.querySelector('.monaco-editor-container');
      if (editorContainer) {
        editorContainer.style.setProperty('display', 'block');
      }
    }

    // é‡ç½®è¾“å‡ºåŒºåŸŸä¸ºæŠ˜å çŠ¶æ€
    const outputArea = document.getElementById('output-area');
    if (outputArea && outputArea.classList.contains('expanded')) {
      outputArea.classList.remove('expanded');
    }
  }

  // åˆ‡æ¢æ¯”è¾ƒæ¨¡å¼
  function toggleCompareMode() {
    // å¦‚æœè¿›å…¥æ¯”è¾ƒæ¨¡å¼ï¼Œå…ˆé‡ç½®ç•Œé¢åˆ°é»˜è®¤çŠ¶æ€
    if (!isCompareMode) {
      resetViewToDefault();
    }

    const compareSection = document.getElementById('compare-section');
    const editorsWrapper = document.getElementById('editors-wrapper');
    const firstSection = document.querySelector('.input-section');

    if (!isCompareMode) {
      // è¿›å…¥æ¯”è¾ƒæ¨¡å¼ - æ˜¾ç¤ºç¬¬äºŒä¸ªç¼–è¾‘å™¨
      isCompareMode = true;
      compareSection.classList.remove('hidden');
      editorsWrapper.classList.add('compare-mode');

      // æ›´æ–°ç¬¬ä¸€ä¸ªç¼–è¾‘å™¨æ ‡é¢˜
      const firstLabel = firstSection.querySelector('.section-label');
      if (firstLabel) {
        firstLabel.textContent = translations.leftJson || 'Left JSON';
      }

      // ç«‹å³æ›´æ–°å·®å¼‚é«˜äº®
      highlightDifferences();
    } else {
      // é€€å‡ºæ¯”è¾ƒæ¨¡å¼
      isCompareMode = false;
      compareSection.classList.add('hidden');
      editorsWrapper.classList.remove('compare-mode');

      // æ¢å¤ç¼–è¾‘å™¨æ ‡é¢˜
      const firstLabel = firstSection.querySelector('.section-label');
      if (firstLabel) {
        firstLabel.textContent = 'All-in-One JSON Viewer';
      }

      // æ¸…é™¤é«˜äº®
      clearHighlightDecorations();

      // æ¸…ç©ºæ¯”è¾ƒç¼–è¾‘å™¨
      if (compareEditor) {
        compareEditor.setValue('');
      }
    }

    // æ›´æ–°å¸ƒå±€
    setTimeout(() => {
      if (editor) editor.layout();
      if (compareEditor) compareEditor.layout();
      if (outputEditor) outputEditor.layout();
    }, 100);
  }

// åœ¨ä¸¤ä¸ªç¼–è¾‘å™¨ä¸­é«˜äº®æ˜¾ç¤ºå·®å¼‚
  function highlightDifferences() {
    if (!editor || !compareEditor) return;

    // æ¸…é™¤ä¹‹å‰çš„è£…é¥°
    clearHighlightDecorations();

    try {
      const leftText = editor.getValue();
      const rightText = compareEditor.getValue();

      if (!leftText.trim() || !rightText.trim()) return;

      const leftJson = JSON.parse(leftText);
      const rightJson = JSON.parse(rightText);

      // æ‰¾å‡ºå·®å¼‚ï¼ŒåŒ…å«ç²¾ç¡®çš„è¡Œå·å’Œåˆ—å·ä¿¡æ¯
      const differences = findDifferencesWithLineNumbers(leftText, rightText, leftJson, rightJson);

      // åœ¨å·¦ä¾§ç¼–è¾‘å™¨ä¸­é«˜äº®å·®å¼‚
      const leftDecorationsData = differences
        .filter(d => d.type === 'removed' || d.type === 'changed')
        .map(d => ({
          range: new monaco.Range(
            d.line || 1,
            d.startColumn || 1,
            d.line || 1,
            d.endColumn || 1000
          ),
          options: {
            className: d.type === 'removed' ? 'diff-removed-decoration' : 'diff-changed-decoration',
            hoverMessage: { value: d.message },
            isWholeLine: d.isWholeLine || false
          }
        }));

      // åœ¨å³ä¾§ç¼–è¾‘å™¨ä¸­é«˜äº®å·®å¼‚
      const rightDecorationsData = differences
        .filter(d => d.type === 'added' || d.type === 'changed')
        .map(d => ({
          range: new monaco.Range(
            d.line || 1,
            d.startColumn || 1,
            d.line || 1,
            d.endColumn || 1000
          ),
          options: {
            className: d.type === 'added' ? 'diff-added-decoration' : 'diff-changed-decoration',
            hoverMessage: { value: d.message },
            isWholeLine: d.isWholeLine || false
          }
        }));

      // åº”ç”¨è£…é¥°
      if (editor && leftDecorationsData.length > 0) {
        leftDecorations = editor.deltaDecorations([], leftDecorationsData);
      }
      if (compareEditor && rightDecorationsData.length > 0) {
        rightDecorations = compareEditor.deltaDecorations([], rightDecorationsData);
      }
    } catch (error) {
      // JSONè§£æå¤±è´¥ï¼Œä¸æ˜¾ç¤ºé«˜äº®
      console.debug('Highlight differences error:', error);
    }
  }

// æŸ¥æ‰¾å·®å¼‚ï¼ˆè¿”å›å¸¦ç²¾ç¡®è¡Œå·ä¿¡æ¯çš„å·®å¼‚ï¼‰
  function findDifferencesWithLineNumbers(leftText, rightText, leftJson, rightJson) {
    const differences = [];

    // è§£ææ–‡æœ¬è¡Œï¼Œç”¨äºç²¾ç¡®å®šä½
    const leftLines = leftText.split('\n');
    const rightLines = rightText.split('\n');

    function findKeyInLines(key, lines, startLine = 0) {
      const keyPattern = new RegExp(`"${key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}"\\s*:`);
      for (let i = startLine; i < lines.length; i++) {
        if (keyPattern.test(lines[i])) {
          const match = lines[i].match(keyPattern);
          if (match) {
            return {
              line: i + 1,
              startColumn: match.index + 1,
              endColumn: lines[i].length
            };
          }
        }
      }
      return { line: 1, startColumn: 1, endColumn: 1000 };
    }

    function compare(val1, val2, currentPath, parentLine = 1) {
      const type1 = typeof val1;
      const type2 = typeof val2;

      // ç±»å‹ä¸åŒ
      if (type1 !== type2) {
        const keyName = currentPath.split('.').pop();
        const position = findKeyInLines(keyName, leftLines, parentLine - 1);
        
        differences.push({
          type: 'changed',
          path: currentPath,
          oldValue: val1,
          newValue: val2,
          message: `${currentPath}: ${JSON.stringify(val1)} â†’ ${JSON.stringify(val2)}`,
          line: position.line,
          startColumn: position.startColumn,
          endColumn: position.endColumn,
          isWholeLine: false
        });
        return;
      }

      // å¦‚æœæ˜¯å¯¹è±¡æˆ–æ•°ç»„ï¼Œé€’å½’æ¯”è¾ƒ
      if (type1 === 'object' && val1 !== null && val2 !== null) {
        const keys1 = Object.keys(val1);
        const keys2 = Object.keys(val2);
        const allKeys = new Set([...keys1, ...keys2]);

        allKeys.forEach(key => {
          const newPath = currentPath ? `${currentPath}.${key}` : key;
          
          if (!(key in val1)) {
            // æ–°å¢ - åœ¨å³ä¾§æ–‡æœ¬ä¸­æŸ¥æ‰¾ä½ç½®
            const position = findKeyInLines(key, rightLines);
            differences.push({
              type: 'added',
              path: newPath,
              value: val2[key],
              message: `${newPath}: + ${JSON.stringify(val2[key])}`,
              line: position.line,
              startColumn: position.startColumn,
              endColumn: position.endColumn,
              isWholeLine: false
            });
          } else if (!(key in val2)) {
            // åˆ é™¤ - åœ¨å·¦ä¾§æ–‡æœ¬ä¸­æŸ¥æ‰¾ä½ç½®
            const position = findKeyInLines(key, leftLines);
            differences.push({
              type: 'removed',
              path: newPath,
              value: val1[key],
              message: `${newPath}: - ${JSON.stringify(val1[key])}`,
              line: position.line,
              startColumn: position.startColumn,
              endColumn: position.endColumn,
              isWholeLine: false
            });
          } else {
            // é€’å½’æ¯”è¾ƒ
            const keyPosition = findKeyInLines(key, leftLines);
            compare(val1[key], val2[key], newPath, keyPosition.line);
          }
        });
      } else if (val1 !== val2) {
        // å€¼ä¸åŒ
        const keyName = currentPath.split('.').pop();
        const position = findKeyInLines(keyName, leftLines);
        
        differences.push({
          type: 'changed',
          path: currentPath,
          oldValue: val1,
          newValue: val2,
          message: `${currentPath}: ${JSON.stringify(val1)} â†’ ${JSON.stringify(val2)}`,
          line: position.line,
          startColumn: position.startColumn,
          endColumn: position.endColumn,
          isWholeLine: false
        });
      }
    }

    compare(leftJson, rightJson, '');

    return differences;
  }

// ä¿ç•™åŸæœ‰çš„ç®€å•å·®å¼‚æ£€æµ‹å‡½æ•°ä½œä¸ºå¤‡ç”¨
  function findDifferences(obj1, obj2, path = '', depth = 0) {
    const differences = [];

    function compare(val1, val2, currentPath, currentLine = 0) {
      const type1 = typeof val1;
      const type2 = typeof val2;

      // ç±»å‹ä¸åŒ
      if (type1 !== type2) {
        differences.push({
          type: 'changed',
          path: currentPath,
          oldValue: val1,
          newValue: val2,
          message: `${currentPath}: ${JSON.stringify(val1)} â†’ ${JSON.stringify(val2)}`,
          line: currentLine
        });
        return;
      }

      // å¦‚æœæ˜¯å¯¹è±¡æˆ–æ•°ç»„ï¼Œé€’å½’æ¯”è¾ƒ
      if (type1 === 'object' && val1 !== null && val2 !== null) {
        const keys1 = Object.keys(val1);
        const keys2 = Object.keys(val2);
        const allKeys = new Set([...keys1, ...keys2]);

        allKeys.forEach((key, index) => {
          const newPath = currentPath ? `${currentPath}.${key}` : key;
          const lineOffset = Math.floor(index / 5); // ä¼°ç®—è¡Œå·

          if (!(key in val1)) {
            // æ–°å¢
            differences.push({
              type: 'added',
              path: newPath,
              value: val2[key],
              message: `${newPath}: + ${JSON.stringify(val2[key])}`,
              line: currentLine + lineOffset
            });
          } else if (!(key in val2)) {
            // åˆ é™¤
            differences.push({
              type: 'removed',
              path: newPath,
              value: val1[key],
              message: `${newPath}: - ${JSON.stringify(val1[key])}`,
              line: currentLine + lineOffset
            });
          } else {
            // é€’å½’æ¯”è¾ƒ
            compare(val1[key], val2[key], newPath, currentLine + lineOffset);
          }
        });
      } else if (val1 !== val2) {
        // å€¼ä¸åŒ
        differences.push({
          type: 'changed',
          path: currentPath,
          oldValue: val1,
          newValue: val2,
          message: `${currentPath}: ${JSON.stringify(val1)} â†’ ${JSON.stringify(val2)}`,
          line: currentLine
        });
      }
    }

    compare(obj1, obj2, path);

    return differences;
  }

  // æ¸…é™¤é«˜äº®è£…é¥°
  function clearHighlightDecorations() {
    if (editor && leftDecorations.length > 0) {
      editor.deltaDecorations(leftDecorations, []);
      leftDecorations = [];
    }
    if (compareEditor && rightDecorations.length > 0) {
      compareEditor.deltaDecorations(rightDecorations, []);
      rightDecorations = [];
    }
  }

  // æ˜¾ç¤ºToastæç¤º
  function showToast(message) {
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰Toast
    let toast = document.getElementById('toast-message');
    if (toast) {
      toast.remove();
    }
    
    toast = document.createElement('div');
    toast.id = 'toast-message';
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 1001;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      animation: slideIn 0.3s ease-out;
    `;
    
    // æ·»åŠ åŠ¨ç”»æ ·å¼
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(toast);
    
    // 3ç§’åç§»é™¤Toast
    setTimeout(() => {
      toast.style.animation = 'slideIn 0.3s ease-out reverse';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
        if (style.parentNode) {
          style.parentNode.removeChild(style);
        }
      }, 300);
    }, 3000);
  }
</script>

